11/11/11: - began coding
          - circle syntax decided as map {:fn f :args '(a b c)}
          - eval-circle written
          - read-qset written
14/11/11: - began fixing eval-circle to accept circles as args
          - eval-circle needs to be recursive:-
            = e.g. (def c0 = {:fn + :args 3 7})
                   (def c1 = {:fn * :args c0 2})
                   (eval-circle c0) => (eval (+ 3 7)) => 10
                   (eval-circle c1) => (eval (* (+ 3 7) 2)) => 20
            = so (eval-circle c1) does this:-
	      # initialise expr => ()
	      # cons (:fn c1) => (*)
	      # look at first arg
	      # c0 is not a number so recur
	      # intialise expr => (* ())
	      # cons (:fn c0) => (* (+))
	      # look at first arg
	      # 3 is a number so cons => (* (+ 3))
	      # look at second arg
	      # 7 is a number so cons => (* (+ 3 7))
	      # back up a level
	      # 2 is a number so cons => (* (+ 3 7) 2)
	      # out of args so eval => (eval (* (+ 3 7) 2)) => 20
          - display for generated code?
	  - not finding clojure.string on netbook?
22/11/11: - wrote fn circ-arg that creates list from circle arg or returns int arg
24/11/11: - wrote fn parse-args to parse output of circ-arg to desconstruct circles
          - currently broken; need function to perform as follows:-
            = begin with input and '()
            = check first arg:-
              # is input '()?  if so, done.  if not, continue
              # if first element is circle, parse-args and cons sublist to output
              # if not circle, cons to output
              # recur with rest of list
05/12/11: - began writing recursive version of parse-args
          - ditching circ-arg, writing parse-circ to conflate circ-arg and parse-args
          - ditching circles as maps, will use lists, starting on gui
          - cba to fight jfx2 anymore so using guiftw/swt again