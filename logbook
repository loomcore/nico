11/11/11: - began coding
          - circle syntax decided as map {:fn f :args '(a b c)}
          - eval-circle written
          - read-qset written
14/11/11: - began fixing eval-circle to accept circles as args
          - eval-circle needs to be recursive:-
            = e.g. (def c0 = {:fn + :args 3 7})
                   (def c1 = {:fn * :args c0 2})
                   (eval-circle c0) => (eval (+ 3 7)) => 10
                   (eval-circle c1) => (eval (* (+ 3 7) 2)) => 20
            = so (eval-circle c1) does this:-
	      # initialise expr => ()
	      # cons (:fn c1) => (*)
	      # look at first arg
	      # c0 is not a number so recur
	      # intialise expr => (* ())
	      # cons (:fn c0) => (* (+))
	      # look at first arg
	      # 3 is a number so cons => (* (+ 3))
	      # look at second arg
	      # 7 is a number so cons => (* (+ 3 7))
	      # back up a level
	      # 2 is a number so cons => (* (+ 3 7) 2)
	      # out of args so eval => (eval (* (+ 3 7) 2)) => 20
          - display for generated code?
	  - not finding clojure.string on netbook?
22/11/11: - wrote fn circ-arg that creates list from circle arg or returns int arg
24/11/11: - wrote fn parse-args to parse output of circ-arg to desconstruct circles
          - currently broken; need function to perform as follows:-
            = begin with input and '()
            = check first arg:-
              # is input '()?  if so, done.  if not, continue
              # if first element is circle, parse-args and cons sublist to output
              # if not circle, cons to output
              # recur with rest of list
05/12/11: - began writing recursive version of parse-args
          - ditching circ-arg, writing parse-circ to conflate circ-arg and parse-args
          - ditching circles as maps, will use lists, starting on gui
          - cba to fight jfx2 anymore so using guiftw/swt again
          - ditched circle maps stuff, currently draws just a blank canvas
          - added "new" and "delete" buttons
          - added "split" button
          - sorted gridlayout, canvas with 3 buttons below it
          - added dummy fns for new, split and del
06/12/11: - began work on gen-circle fn to generate an agent representing each circle
          - added doc strings
          - decided gen-circle would be better as a macro defcircle
          - wrote defcircle, creates an agent containing a list representing the function
          - need to rewrite defcircle to check if an arg is an agent and deref it
          - added agent? to check if arg is an agent
          - added make-vals to take a mixed list of ints and agents and return a list of ints and agents derefed
          - for some reason (first l) returns the symbol; calling eval on it seems to work to get the agents out of the list
          - defcircle *nearly* works but is evaling circles and not updating, rather than adding lists and changing with edits to dependant circles
          - dodgy quoting in defcircle, sort it out
07/12/11: - working on defcircle again, trying macroexpand et al.
          - figured don't actually need circles as agents, can just redefine on modification so working on a new defcircle to gen lists
          - got a nesting defcircle using lists now,  just need to make it use symbols rather than the list the symbol resolves to; need a fn to iterate across a list and quote the symbols
          - sorted defcircle, need a fn to iteratively eval elements of a circle sexp
          - turned out didn't need a fn to quote symbols in a list as they are by default symbols when accessed from a list
          - wrote framework for eval-circle, need to figure out what goes in place of "something" and "something else"
          - writing fn nested? to check if circle contains other circles
          - wrote rough version of eval-circle using nested? for a base case