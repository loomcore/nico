% The master copy of this demo dissertation is held on my filespace
% on the cl file serve (/homes/mr/teaching/demodissert/)

% Last updated by PMY on 3 March 2012

\documentclass[12pt,twoside,notitlepage,xetex]{report}

\usepackage{a4}
\usepackage{verbatim}
\usepackage{epsf}
\usepackage{sectsty}

\usepackage{url}
\usepackage{parskip}
\usepackage{pdfpages}
% \usepackage{wrapfig}
\usepackage{subfig}
\usepackage[normalem]{ulem}
\usepackage{caption}
\usepackage{color}
\usepackage{float}
% \usepackage{lettrine} % dropped capitals at start of chapter
\usepackage{fancyvrb}
% \usepackage{cprotect}
\usepackage{lscape}

\usepackage{graphicx}
\usepackage{fontspec,xunicode}
\defaultfontfeatures{Mapping=tex-text, Numbers=Monospaced}% ,Scale=MatchLowercase% , Numbers=OldStyle
\setmainfont[Scale=1]{Linux Libertine O}% {Sabon MT Std}
\setsansfont{Roboto Bold}% {Myriad Pro Light}
\setmonofont[Scale=0.82]{Monaco}% {Droid Sans Mono}
\allsectionsfont{\sffamily}

\newfontinstance\bigsf[Color=000000,Scale=1.25]{Roboto Bold}% {Myriad Pro Light}
\newfontinstance\sfapp[Color=000000,Scale=0.82]{Roboto Regular}% {Myriad Pro Light}

\definecolor{red}{rgb}{0.80,0.00,0.00}
\definecolor{green}{rgb}{0.00,0.80,0.00}
\definecolor{blue}{rgb}{0.00,0.00,0.80}

\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex

\raggedbottom                           % try to avoid widows and orphans
\raggedright                            % left-aligned, not justified
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\renewcommand{\captionfont}{\footnotesize}

\setcounter{secnumdepth}{5}
% \setcounter{tocdepth}{5}

\begin{document}
\nocite{*}
\bibliographystyle{plain}% {unsrt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

% \hfill{\LARGE \bf \sffamily Philip Yeeles}
\hfill{\Large Philip Yeeles}

\vspace*{60mm}
\begin{center}
\LARGE
{\bf \bigsf Nico: An Environment for Mathematical Expression in Schools}\\
\vspace*{5mm}
% {\sffamily Computer Science Tripos} \\
Computer Science Tripos\\
\vspace*{5mm}
% {\sffamily Selwyn College} \\
Selwyn College\\
\vspace*{5mm}
% {\sffamily \today}  % today's date
\today % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
\bf Name:               & Philip Yeeles                                                   \\
\bf College:            & Selwyn College                                                  \\
\bf Project Title:      & Nico: An Environment for Mathematical\\
                        & Expression in Schools \\
\bf Examination:        & Computer Science Tripos, May 2012                               \\
\bf Word Count:         & TBC\footnotemark[1]
(well less than the 12000 limit) \\
\bf Project Originator: & P.~M.~Yeeles (\verb¬pmy22¬)                                    \\
\bf Supervisors:        & Dr S.~J.~Aaron (\verb¬sja55¬), A.~G.~Stead (\verb¬ags46¬)     \\
\end{tabular}
}
\footnotetext[1]{This word count was computed
by {\tt detex diss.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w}
}
\stepcounter{footnote}


\section*{Original Aims of the Project}

The aim of the project was to develop an application in the Clojure programming
language which would allow users to express mathematical calculations using a
graphical notation.  The software was to be able to generate an abstract syntax
tree from the graphical notation, evaluate it and pass the results back to the
application in under 300ms.  An extension to the project was to conduct a user
study to evaluate the utility of the software.
%
% To write a demonstration dissertation\footnote{A normal footnote without the
% complication of being in a table.} using \LaTeX\ to save
% student's time when writing their own dissertations. The dissertation
% should illustrate how to use the more common \LaTeX\ constructs. It
% should include pictures and diagrams to show how these can be
% incorporated into the dissertation.  It should contain the entire
% \LaTeX\ source of the dissertation and the Makefile.  It should
% explain how to construct an MSDOS disk of the dissertation in
% Postscript format that can be used by the book shop for printing, and,
% finally, it should have the prescribed layout and format of a diploma
% dissertation.


\section*{Work Completed}

I have successfully designed and implemented the application detailed in the
previous section.  That is, I have developed an application in which it is
possible to express calculations using a graphical notation, that generates an
abstract syntax tree from the language and that is able to parse the tree and
return the results in under 300ms.  I have also conducted a user study to assess
whether or not the software is actually of use with regard to mathematics
education.
%
% All that has been completed appears in this dissertation.

\section*{Special Difficulties}

Learning the Clojure programming language.
%
% Learning how to incorporate encapulated postscript into a \LaTeX\
% document on both CUS and Thor.

\newpage
\section*{Declaration of Originality}

I, Philip Michael Yeeles of Selwyn College, being a candidate for Part
II of the Computer Science Tripos, hereby declare that this dissertation
and the work described in it are my own work, unaided except as may be
specified below, and that the dissertation does not contain material
that has already been used to any substantial extent for a comparable
purpose.

\bigskip
\leftline{Signed}

\medskip
\leftline{Date \today}

\cleardoublepage

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}
My thanks to Luke Church for his advice regarding user studies, and to Alistair
Stead and Sam Aaron for their encouragement and patience.
%
% This document owes much to an earlier version written by Simon Moore
% \cite{Moore95}.  His help, encouragement and advice was greatly
% appreciated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering
                        % is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}
% TODO: sort out cogdims: apparently the proper way to do it is to mention cogdims and cite petra & green, then put all the cogdims terms in italics

% \lettrine{T}{he}
The aim of this project has been to design and develop a notation and
accompanying application to act as a learning aid for pre-algebra arithmetic by
increasing visibility, reducing the number of hidden dependencies and making the
flow of data obvious to the user.  I have successfully developed such a system,
intended initially for pupils in Year 5 (though extensible, through the creation
of alternative question sets, to other age groups), and, as an extension,
conducted a user study to assess its utility.

In this chapter, I will discuss my motivations for choosing this project, the
pros and cons of the handwritten system it is attempting to augment, the
technical challenges involved in developing such a system and related work that
has previously been conducted with similar goals.

\section{Motivations}
% evaluation of problems with writing it down on paper
% cogdims of handwritten method(s)
% system requirements (cogdims)

My motivations behind this project lay in the limitations of the handwritten
approach to solving mathematical problems that I had observed both in my own
learning and in my own teaching experience.  What follows is an evaluation of
the pros and cons of the handwritten method of performing arithmetic
calculations according to Blackwell and Green's ``Cognitive Dimensions''
framework \cite{Blackwell1998}, and a discussion of the properties a useful
alternative notation should have.

\pagebreak

% \subsection{Evaluation of the Handwritten Approach}
% % moved to chapter 2 requirements analysis

% \subsection{Requirements of a Replacement System}
% % moved to chapter 2 requirements analysis

\section{Technical Challenges}
% need first-class functions
% need to be able to pass expressions around to evaluate at will: hence functional, hence lisp - homoiconicity
% also need good gui libraries for app - familiar with java/swing so that works (esp. with seesaw), also the option of jfx2 and swt/guiftw
% difficulty of learning clojure over summer in preparation

Developing such an application comprises two main challenges: developing a
back-end that is capable of creating, storing, editing, deleting, evaluating,
nesting and calculations, and a graphical, user-facing frontend that is able to
render calculations into the devised notation, and allow the user to perform
operations upon the notation that affect the underlying calculation.

I chose to use the Clojure language as it provided many features that would
prove to be useful over the course of the application's development.  As a
dialect of LISP, Clojure is a homoiconic programming language -- that is, a
programming language in which code is represented as a data structure -- which
made passing around and performing operations upon calculations themselves,
rather than just their results, considerably easier.  A calculation can simply
be represented as a piece of code, which can then be utilised as needed.

As the user experience is so crucial to the success of the application, it was
also important that there be well-established GUI libraries available.  Clojure
runs on the Java Virtual Machine (JVM), which puts Java's considerable standard
library at one's disposal, whilst still being able to program in a LISP.  As I
am familiar with Java and the Swing GUI libraries, it was advantageous to be
able to leverage this knowledge in designing the application's interface.

\section{Previous Work}
% scrubbing calculator http://worrydream.com/ScrubbingCalculator/
% soulver http://www.acqualia.com/soulver/
% neither really targeted at education
% cool stuff at http://worrydream.com/KillMath/ though
% maybe refer to this? http://betterexplained.com/articles/rethinking-arithmetic-a-visual-guide/
% also, this: http://www.ralph-abraham.org/articles/Blurbs/blurb126.shtml
% also, check out espresso and education city stuff, log in to fronter via st. mary's site, uname jyeele1.314, pword b3ach7
% plenty of work been done in making computer maths like paper maths, but not so much the reverse, case in point: http://www.macresearch.org/showcase-review-pi-cubed-iphone-ipod-touch
% also a lot of crap maths games that are essentially a series of qs in disguise, see http://www.time4learning.com/curriculum/try_demos.html
% nico is unabashedly *not* a game, rather a tool, much like a pen or calculator
% problem with calculators?

There already exists a wide variety of educational software for mathematics, but
much of this is in the form of ``games'', in which a series of mathematical
problems to be solved is poorly disguised as a game -- indeed, such problems
would be more accurately said to be embedded into a game, rather than becoming
the game themselves.  Thus, the object becomes not to solve the problems, but to
play the game that happens to surround the problems.  Such software also does
not often offer any means of solving the problems, other than the traditional
pen-and-paper method (with a piece of paper next to the computer screen), or
the mental approach.  Hence, what the user is then presented with is essentially
a game and a worksheet, awkwardly interleaved.  In some cases, it is even
possible for the user to simply press arbitrary buttons until they pass the
questions, effectively removing the maths element of the game and replacing it
with a series of short breaks in gameplay. % citations!

There also exist a few applications intended to represent calculations on a
computer in novel ways.  A relatively common approach to this has been to try
to make on-screen calculations more like on-paper calculations.  \emph{Pi Cubed}
takes this approach by trying to make complex calculations appear as they would
be written in an exam or exercise book \cite{PiCubed}.  \emph{Soulver},
conversely, tries to achieve this by simulating ``back-of-the-envelope''
calculations, whereby notes in English augment the calculation \cite{Soulver}.
Another approach is that of the \emph{Scrubbing Calculator} \cite{ScrubCalc},
which extends the \emph{Soulver}-style environment by helping the user to solve
equations by dragging values to increase and decrease them, showing how changing
a value affects the overall result.  Values can be linked by dragging a line
between them, which means that they are two instances of the same value -- hence
dragging one changes the value at every location in which it appears.  This is a
neat means of visualising equations, but it, too, is not intended for use in
education, and still requires the user to be able to formulate some kind of
equation.  The \emph{Scrubbing Calculator} is more a tool for facilitating
algebraic understanding, as opposed to arithmetic understanding; indeed, it is
inherently a {\bf calculator}, and so does not encourage thinking about how to
work out the arithmetic parts of a calculation manually.

\section{Summary}
% need a system that incorporates these features: foo, bar, baz, quux

Existing educational ``games'' for mathematics either have too much focus on
being a game, rather than helping to learn mathematics, or are such that the
mathematical element is circumventable.  There exists software to aid in
calculation and arithmetic by representing it clearly, but it is not intended
for educational use, and often its purpose is to make on-screen calculations
appear as one would handwrite them.

There is a niche for a tool for use in education that represents calculations in
a visual manner, with a particular focus on making the method by which arithmetic
problems are solved clear.  My project aims to provide an environment in which
the user can explore the many ways in which a problem can be solved using a
novel graphical notation.

\cleardoublepage



\chapter{Preparation}

% In this chapter I will discuss the work that was done prior to beginning the
% project proper.  This includes learning the Clojure programming language and
% researching and auditioning graphical metaphors for calculation.  This chapter
% comprises a requirements analysis, followed by an overview of the system
% architecture and a discussion of the additional tools used in the development of
% the project.
This chapter concerns the work that was completed prior to beginning the
project proper.  It comprises a requirements analysis, followed by a discussion
of the prototyping process of the graphical notation to be implemented in the
final application.  Finally, there will be a brief examination of the tools
used in the development of the project.

\section{Requirements Analysis}
% http://www.cs.fsu.edu/~lacher/courses/COP3331/rad.html
% http://www.nd.gov/itd/files/services/pm/requirements-analysis-guidebook.pdf

% TODO: write about the requirements analysis and why we're doing one

\subsection{Current System}
% move evaluation of handwritten arithmetic from chapter 1 here?

\begin{figure}
% \begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\subfloat[]{
\parbox{2cm}{
\begin{center}
{\small
24+35=59\\
12+48=60\\
59+72=131\\
1+60=61\\
131+61=192}
\end{center}}}
\subfloat[]{
\parbox{2cm}{
\begin{center}
{\small
24+35={\color{green}59}\\
12+48={\color{blue}60}\\
{\color{green}59}+72={\color{green}131}\\
1+{\color{blue}60}={\color{blue}61}\\
{\color{green}131}+{\color{blue}61}=192}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
{\small
24+35= {\color{red}\sout{59}} {\color{green}49}\\
12+48={\color{blue}60}\\
{\color{red}\sout{59}} {\color{green}49}+72= {\color{red}\sout{131}} {\color{green}121}\\
1+{\color{blue}60}={\color{blue}61}\\
{\color{red}\sout{131}} {\color{green}121}+{\color{blue}61}= {\color{red}\sout{192}} 182}
\end{center}}}
\end{center}
\caption{Illustrating the hidden dependencies and viscosity inherent in pre-algebra, handwritten arithmetic.  The original calculation is shown in (a), has its otherwise-hidden dependencies highlighted in (b), and is altered slightly in (c).}
% \end{wrapfigure}
\end{figure}
% cogdims
% taught method without being taught *why* it works
% high viscosity - have to cross things out or start again
% high repetition viscosity
% low knock-on viscosity
% viscosity is acceptable in transcription and incrementation, but harmful to modification and exploration
% hidden dependencies -
% premature commitment - made worse by high repetition viscosity; have to start again if a mistake is made
% premature commitment is certainly very high for traditional calculators
% algebra is abstraction-hungry, arthimetic is abstraction-hating, though can use secondary notation to construct abstractions
% no abstraction barrier to arithmetic though
% secondary notation - notes around calculations
% visibility - visible, but only juxtaposable if juxtaposed at the start (premature commitment) or with the help of secondary notation
There are a number of problems with handwritten, pre-algebra arithmetic that
this project seeks to rectify.  First of all, the fact that it is handwritten
entails a high level of viscosity: it is difficult to make changes to a written
calculation without sacrificing clarity.  In particular, there is a lot of
repetition viscosity involved in the modification of an existing piece of work;
if a number is changed that is used in several calculations, then it is
time-consuming to change it everywhere it appears in the working.  If several
calculations are dependent upon each other, then this entails a lot of knock-on
viscosity in recalculating each stage after changing the number.  This is
exacerbated by the hidden dependencies between chained calculations in
handwritten arithmetic (\emph{Fig. 2.1}).  The problem of hidden dependencies
is made worse by the low juxtaposability of the system; although the notation
is quite visible, in that every calculation can be seen easily on the page,
juxtaposing two sets of calculations entails considerable premature commitment
on the part of the user, as components cannot easily be edited or relocated due
to the system's high viscosity.  Whilst viscosity can be acceptable in some
situations, it is harmful with regard to modification and exploration within a
notational system, once again requiring a non-trivial amount of premature
commitment on the part of the user.  In many cases, it can actually quicker for
the user to start all over again, as opposed to making the changes required to
rectify their calculations.

Handwritten arithmetic does have one key advantage: it has a very low initial
abstraction barrier.  Other than learning the appropriate symbols for each
operation and digit, and how to combine them, the traditional system of
arithmetic allows a learner to begin using it almost immediately.  Algebra, on
the other hand, has a much higher abstraction barrier, requiring the much more
abstract concept of a variable, rather than a set quantity, to be used
effectively.  Although it is possible to add abstractions to arithmetic by the
use of secondary notation, there is no provision for abstraction included in
the primary notation.  It can, therefore, be said that algebra is an
\emph{abstraction-hungry} system, whereas arithmetic is an
\emph{abstraction-hating} system.  Without abstractions, arithmetic is easy to
get started with, but can be a very verbose and inefficient notation with low
visibility, as outlined above.

\subsection{Proposed System}

\subsubsection{Overview}
% cogdims!!
% need to develop useful notation - early studies, talk about other notations we came up with, notations looked at with alistair (get link)
% hidden dependencies - nico shows a data flow representation (p19, blackwell1998) to make dependencies explicit

% TODO: this bit.  not even sure if it should be in the intro...

To improve upon the standard approach of listing the steps comprising a
calculation, a system must acknowledge and try to overcome the drawbacks listed
above.  To this end, I have designed and developed a notational system and
accompanying applciation that aims to overcome many of the disadvantages
inherent in traditional, handwritten arithmetic.  The intention of the system
is to reduce viscosity, increase visibility and to remove many of the hidden
dependencies that beleaguer the traditional method. % TODO: not ahppy with this; not sure it counts as an overview


\subsubsection{Functional Requirements}

To be an improvement upon the current system detailed above, the new system must
satisfy the following properties:-- % TODO: not happy with this
\begin{itemize}
\item Allows the user to create graphical structures representative of complex calculations
\item Provides the user with a suitable environment in which to do so
\item Allows the user to reposition elements of the structure at will
\item Displays the user's current progress
\item Is able to evaluate the correctness of the user's answer
\item Accepts a file containing a set of questions to be answered
\item Displays the current question being answered
\item Progresses through the current question set as the user answers each question correctly
\end{itemize}

\subsubsection{Non-Functional Requirements}

The system must also satisfy a number of requirements outside of its basic
functionality.  These are listed below.
\begin{itemize}
\item Offers a significant improvement in visibility over handwritten arithmetic
\item Offers a significant improvement in juxtaposability over handwritten arithmetic
\item Reduces premature commitment relative to handwritten arithmetic
\item Reduces hidden dependencies relative to handwritten arithmetic
\item Is interactive: is able to pass results back to the user in less than 300ms\footnote{Roca and Rousseau \cite{Roca2004} have this to say on the subject of interactivity: ``An abundance of studies into user tolerance of round-trip latency [...] has been conducted and generally agrees upon the following levels of tolerance: excellent, 0-300ms; good, 300-600ms; poor, 600-700ms; and quality becomes unacceptable [...] in excess of 700ms.''}
\item Is appealing to the target audience of 9- to 10-year-olds without being childish -- must be applicable to a wider audience if needed (e.g. could it be extended for use in adult education?)
\end{itemize}
% talk about needing to be appealing, etc.?
% more details in notes on user interface subsection in chapter 3

% \subsubsection{Use Case}
%
% % diagram?  see wikipedia "use case"
% lol

% \section{System Overview}
% % do we need if in req. analysis?
%
% lol

\section{User Interface}
% section rather than subsection?  def. section if we don't have system overview
% prototypes!  dig out the preliminary drawings, take screenshots of old versions for later

As this project is primarily concerned with human-computer interaction, the
user interface and experience, and the design thereof, constitutes a
significant part of this project.  As such, this section outlines the initial
development stages of the user interface, first introducing several designs for
the graphical notation, and then discussing in more detail three that were
developed further.

\subsection{Prototyping}

\subsubsection{Low-Fidelity Prototyping}

% drawings 'n' shit
% talk about how decided to come up with 20 different designs then thin them out
To try to get some initial ideas for what could become the calculation metaphor
of choice for the project, a target was set of devising at least twenty,
significantly different, potential designs.  These were recorded as very rough
sketches, a few of which were refined in larger examples, and three of which
were deemed good enough to warrant an application mockup, as detailed in
\emph{Sec. 2.2.1.2}.

% \newpage

% \paragraph{Flowgraphs}\hfill

\begin{center}
\begin{figure}[H]
% \begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11a.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11b.jpg}
\end{center}}}
\end{center}
\caption{Early designs for flowgraph-based calculation metaphors.}
% \end{wrapfigure}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{figs/mockups/sketches/11/11jii.jpg}
\end{center}
\caption{A more refined sketch of a flowgraph-based language and application.}
\end{figure}
\end{center}

% \newpage

% \paragraph{Triangles}\hfill

\begin{center}
\begin{figure}[H]
% \begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/21/21b.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/22/22a.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/22/22b.jpg}
\end{center}}}\\
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/42/42a.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/42/42b.jpg}
\end{center}}}
\end{center}
\caption{Early designs for triangle-based calculation metaphors.}
% \end{wrapfigure}
\end{figure}
\end{center}

\begin{center}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{figs/mockups/sketches/31/31a.jpg}
\end{center}
\caption{A more refined sketch of a triangle-based language.}
\end{figure}
\end{center}

% \newpage

% \paragraph{Circles}\hfill

\begin{center}
\begin{figure}[H]
% \begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12a.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12b.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12c.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12f.jpg}
\end{center}}}\\
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12h.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/41/41a.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/41/41b.jpg}
\end{center}}}
\end{center}
\caption{Early designs for circle-based calculation metaphors.}
% \end{wrapfigure}
\end{figure}
\end{center}

\begin{center}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{figs/mockups/sketches/21/21a.jpg}
\end{center}
\caption{A more refined sketch of a circle-based language.}
\end{figure}
\end{center}

% \newpage

% \paragraph{Other}\hfill

\begin{center}
\begin{figure}[H]
% \begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11c.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11d.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11e.jpg}
\end{center}}}\\
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11f.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11g.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11h.jpg}
\end{center}}}
\end{center}
\end{figure}
\newpage
\begin{figure}
\ContinuedFloat
\begin{center}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11i.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11k.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11li.jpg}
\end{center}}}\\
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11lii.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11m.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12d.jpg}
\end{center}}}\\
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12e.jpg}
\end{center}}}
\end{center}
\caption{Assorted early designs for other calculation metaphors.}
% \end{wrapfigure}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12gi.jpg}
\end{center}}}
{\Huge $ \rightarrow $}% arrow
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12gii.jpg}
\end{center}}}
{\Huge $ \rightarrow $}\\% arrow
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12giii.jpg}
\end{center}}}
{\Huge $ \rightarrow $}% arrow
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12giv.jpg}
\end{center}}}
{\Huge $ \rightarrow $}% arrow
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12gv.jpg}
\end{center}}}
\end{center}
\caption{A sample progression of a calculation in a language based around infinitely halving a rectangle.}
\end{figure}
\end{center}

% \newpage

% \subsubsection{Preliminary Designs}
\subsubsection{Detailed Mockups}
% examples done using that prototyping software - balsamiq mockups
% draft designs on pwf

Some preliminary designs for the application and graphical language follow,
being more mature versions of three of the low-fidelity prototypes presented
above.  First is a combined flowgraph representation and
Read-Evaluate-Print-Loop (REPL) design.  The second design uses the Sierpiński
triangle as a basis for the visual metaphor.  The final design is the
circle-based language that eventually became the foundation for the rest of the
project.

\paragraph{Flowgraph Metaphor}\hfill

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-4cm]{figs/mockups/flowgraph/img/fg-000.jpg}
\caption{The prototype flowgraph-style language.}
\end{center}
\end{figure}

The flowgraph idea initially outlined in the project proposal and included in
the low-fidelity prototypes above appears here as a more mature, revised
prototype, showing two screens of a sample application.  The top screen shows
the proposed application manipulating the graphical language, whilst the bottom
screen shows a REPL utilising a simple text-based language for users more
comfortable with writing than the visual metaphor.

% TODO: add scroll bar to box selection panel?  have claimed that it's scrollable but it's not showing it!
% TODO: similarly for the canvas
The application is comprised of one window containing several panels.  The
current question being answered is displayed in the top left-hand corner.
Below this, a scrollable panel running down the left side of the window
contains the fundamental components of the notation: boxes representing numbers
and operations, both provided and user-defined, with two buttons below to
change the action of clicking the mouse (explained in greater detail below).  A
panel that runs along the top of the window contains output boxes, areas that
display the result of a calculation at a user-determined point in the
application.  Further boxes appear here as the user demands them, by using the
{\sfapp Show} function.  The {\sfapp ANS} box is a specialised case of this,
which displays what the user currently wishes to submit as the answer to the
question.  The canvas panel occupies the majority of the window, and this is
the area in which the answer is constructed using the various components of the
graphical language.  In the top right-hand corner of the canvas are three
buttons, to zoom in and out of the current calculation and to bring up a help
window.  For especially large or zoomed-in calculations, the canvas is
scrollable.  At the bottom of the window are two tabs, {\sfapp Flow} and
{\sfapp Worksheet}.  When {\sfapp Flow} is selected, the graphical language is
available for use in answering the question.  When {\sfapp Worksheet} is
selected, the user is able to use a simple textual language in a REPL to answer
the question.

Of all the prototypes shown here, this version of the graphical language is the
most like a traditional programming language, in that it allows the user to
define reusable functions, and includes functionality similar to print
statements.  The icons at the side of the application are used to select the
desired function, from a set that includes addition, subtraction,
multiplication, division, exponentiation, number input, {\sfapp Show},
{\sfapp Define} and {\sfapp Join}.  Addition, subtraction, multiplication,
division and exponentiation are all dragged-and-dropped from the icons at the
side to a point on the canvas, causing a box containing their respective
functions to appear at that point.  Number input ({\sfapp \#}) is similar, but
the user inputs a number using the keyboard after the box is created.  The box
then contains that number.  {\sfapp Show} displays the output of the junction to
which its arrow points, in the output box at the top of the screen with the label
input by the user after placing it.  If the box with the label does not yet
exist, it is created next to the existing output boxes.  {\sfapp Define} and
{\sfapp Join} are not boxes to be dragged-and-dropped; they are modes of
operation.  When {\sfapp Define} is activated, dragging the mouse on the canvas
draws a box around sections of the diagram -- the user is able to define
functions by doing so, and by providing a label for the section of diagram that
has been highlighted, a corresponding box can be dragged-and-dropped from the
list of icons (as show in \emph{Fig. 2.2} with the {\sfapp times ten}
function).  When {\sfapp Join} is active, dragging between two points on the
canvas creates an arrow between them that means that the source of the arrow is
used as an argument to the destination of the arrow.  In defining functions,
if arrows cross the boundary of the definition box and they are incoming, input
is required to future uses of the function.  One outgong arrow is allowed to
indicate the output of the function.  Using this notation, answers are submitted
by {\sfapp Show}ing the output at a point in the calculation to the output box
{\sfapp ANS}.

This particular graphical language tries to have a very high visibility,
minimising the number of hidden dependencies between calculations by making
every connection explicit: as a dataflow representation of a calculation
\cite{Blackwell1998}, the flow of information through the diagram is made very
clear.  This language is considerably less viscous than the handwritten method,
as it is trivial (albeit not demonstrated in \emph{Fig. 2.2}) to remove and
replace a box or arrow in the diagram, as opposed to writing out a new set of
calculations or replacing several instances of a component by crossing them
out.  Each box is able to be relocated on the canvas, increasing the
juxtaposability of the system, and the user is able to define their own
abstractions.

The textual language improves upon the traditional means of handwriting
arithmetic by revealing otherwise-hidden dependencies using references to line
numbers.  As the target audience is not yet required to have formally learnt
(or, indeed, encountered) algebra, this notation includes a function \verb¬:¬,
which takes a single number \emph{n} as an argument and returns the result of the
calculation performed on line \emph{n}.  Answers are submitted using a function
\verb¬answer¬ that takes a single number (shown here using a line reference that
is resolved to a number) as an argument.  Other functions include addition,
subtraction, multiplication, division and exponentiation, all of which take two
or more numerical arguments and are used in the familiar infix form.  A function
\verb¬define¬ is also included, although not shown here.  Finally, there is the
\verb¬show¬ function, which behaves similarly to a print statement.  It takes a
numerical argument \emph{n} followed by a string argument \verb¬str¬, and
displays \emph{n} in the output box named \verb¬str¬ at the top of the screen.
If there exists no such output box, it is created next to the existing boxes.
Note that \verb¬answer n¬ is logically equivalent to \verb¬show n "ANS"¬; the
\verb¬answer¬ function was included here to increase clarity.

This design was abandoned as it was deemed to be too complex for the target
audience (Year 5).  The intention of this project is not to implement yet
another programming language for learners, and by providing features like the
REPL and function definition, the system unnecessarily overprovides.  In
addition to this, the flowgraph representation had a number of shortcomings.
For example, it is not immediately clear in what order the arguments feed into
an operation, which is confusing for non-commutative functions such as
subtraction.  Furthermore, the language is quite verbose.  Although this is not
inherently a disadvantage, a more compact representation would be preferable,
in order to make expressions written in the notations more readable to people
other than the author.

\paragraph{Sierpiński Triangle Metaphor}\hfill

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{figs/mockups/sierp/sierp_mockup_full.png}
\caption{The prototype Sierpiński-triangle-based language.}
\end{center}
\end{figure}

This prototype uses a zooming instance of the Sierpiński triangle fractal as
the basis of its notation.  It is shown here manipulating a simple calculation.

The application consists of a single window containing two panels and a canvas
area.  The right-hand panel displays the current total of the calculation,
and the other panel displays the question currently being answered.  In the
canvas area, there are buttons for zooming in and out, a help button and
buttons controlling the composition of structures within the language.  When a
triangle has been selected by clicking on it, clicking the {\sfapp Op} button
presents the user with a choice of operations (namely +, -, × and ÷) to use in
the bottom segment of the triangle.  Clicking either of the {\sfapp Input}
buttons allows the user to input a value into their respective sections, and
clicking on the {\sfapp Split} button creates a new triangle expression within
the left-hand triangle.

This notational system is based around binary operations represented as the
component triangles of a Sierpiński fractal, the logic behind this being that
the fractal structure emphasises that each calculation is part of a larger
whole.  The notation is read by using the left and right sub-triangles as
arguments (left first, right second) to the operation in the bottom triangle.
The structure is colour-coded, such that each subexpression is a different
colour to its precedent superexpression.  This allows the user to abstract away
subexpressions as units to be manipulated as any other input to an operation
would be.  The hidden dependencies of the handwritten method are greatly
diminished in this manner, as viewing the internal structure of a
calculation's subexpressions is simply a matter of zooming-in to the
appropriate triangle.  Viscosity is also considerably reduced, as making a
change in one expression does not require the change to made anywhere else, as
the results of that expression are passed to the rest of the calculation.  This
does not completely remove viscosity, as a misresrepresented value still has to
be replaced several times if it appears in several different expressions, but
this is still an improvement over handwriting.  Indeed, the fact that
calculations are editable more than once, by virtue of using a computer rather
than paper, makes this less viscous than pen and paper.  The system is quite
visible, but has a very low juxtaposability, as all calculations are restricted
to their respective places in the triangle template.

This design was ultimately abandoned as it was deemed to be awkward for a
number of reasons, not least because it was based solely around binary
operations, meaning that to solve the simple question 1+2+3+4, one has to either
calculate ((1+2)+3)+4, which is inefficient, or mentally calculate that
1+2+3=6, and then calculate 6+4, which is obviously unacceptable for a system
that intends to help the user express themselves mathematically.  The severe
lack of juxtaposability is also a problem: as each expression must fit into the
larger structure, it is not possible to reorder them at will, without
fundamentally altering the calculation being performed.  It also enforces a
top-down approach to calculation: one is required by the system to begin with the
outermost calculation and work inwards.  There is no provision for putting a
larger triangle around an existing calculation.  In addition to this, a
somewhat-informal survey of potential notations was conducted, asking
approximately ten subjects to answer some sample questions in this notation and
the circle-based notation (below).  Subjects found this notation less clear,
and were much better able to complete questions correctly using the circle
notation.
% survey
% TODO: can't put subexpressions into right-hand triangle

% what/mockup
% application
% language
% abandoned

\paragraph{Circle Metaphor}\hfill

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{figs/mockups/circles/nico_circmock.png}
\caption{The prototype circle-based language.}
\end{center}
\end{figure}

This prototype uses a notation based around circles as individual units of
calculation, linked in such a way as to indicate the flow of information.
Although it is related to the flowgraph metaphor (above), it has a number of
key differences.

The application comprises, similarly to the Sierpiński model above, a single
window with two panels and a scrollable canvas area, with some buttons to
control the input of data.  The right-hand panel shows a running total of the
user's calculation, and the other panel shows the question currently being
answered.  The canvas area has three buttons at the bottom: zoom in, zoom out
and help.  The larger buttons above these control the action that clicking the
mouse on the canvas performs.  When {\sfapp New} is active, clicking on the
canvas creates a new circle at that location.  When {\sfapp Split} is active,
clicking on a circle increases the number of arguments it has (initially two,
up to a maximum of eight).  When {\sfapp Function} is selected, clicking on a
circle presents the user with a choice of +, -, × and ÷ to use as that circle's
operation.  When {\sfapp Input} is selected, as shown in \emph{Fig. 2.4}, the
user is presented with two further options, {\sfapp Number} and
{\sfapp Circle}.  When {\sfapp Number} is active, clicking on a circle's
argument allows the user to change the value of that argument.  When
{\sfapp Circle} is active, the user is able to click and drag from one circle
to an argument of another, indicating that they wish to use the results of one
circle's calculation as the argument to another circle's calculation.  Finally,
the {\sfapp Answer} button submits the current total as the answer to the
current question.

This notational system uses linked circles representing individual expressions
as its primary metaphor for constructing calculations.  It is similar to the
flowgraph metaphor presented above, except that instead of boxes for each
argument and operation all linked together, single, linkable objects in this
system are complete expressions, rather than components.  Also, there is only
one visible output, namely the overall result of the calculation as a whole.
As for the circles themselves, they consist of an operation at the centre,
orbited by arguments, which are evaluated clockwise from 0°.  Each argument can
either be a number or the tail of another circle, representing the result of
the calculation that that circle stands for.  The circles are colour-coded,
with each `layer' having its own colour.  In this case, the root circle is red,
the circles feeding directly into it are yellow, the circles feeding into those
circles are green and the circles feeding into those are blue.  It is possible
to move circles around the canvas by clicking and dragging them to the desired
location.  Compared to the handwritten approach, this notational system is much
more visible, and very much more juxtaposable, allowing the user to construct
the diagram in a way that is comfortable for them, and allowing them to compare
elements side-by-side if they need to.  Unlike with the Sierpiński metaphor,
the user is not restricted to one order or pattern of constructing a
calculation: calculations can be performed bottom-up, top-down or a mixture of
both, as is comfortable for the individual user.  The system of tails feeding
into other circles also makes the dataflow clear, eliminating many of the
hidden dependencies of handwritten calculation.  For similar reasons to the
flowgraph metaphor, the circle notation also reduces viscosity, as changing a
subexpression automatically alters all of its superexpressions.  Finally, the
system requires little premature commitment, as piece of the diagram can be
created, deleted and swapped in and out at will, so it is ideal for
exploration, allowing the user to try many ways of solving a problem within the
application, rather than having to use a secondary notation or device to help
work through a problem in a more familiar manner and then transcripting that
solution into the new notation.

This design was the one that was ultimately chosen as the basis for the project
as it neatly solved, or at least ameliorated, many of the problems listed with
handwritten arithmetic, without being too complex for the target audience (as
with the flowgraph system), and without being too restrictive with regard to
mathematical expression.  In addition to this, the results of the survey
mentioned above also indicated that people got on well with this notation; the
test subjects found it considerably easier to use than the Sierpiński notation,
and made fewer mistakes in handwriting this notation than the alternative.
% survey

% what/mockup
% application
% language
% chosen

% \section{Additional Tools}

% Luke's:
% Throughout the project, I developed additional support tools to assist with
% design, development and testing. These will be described at the relevant place
% in the implementation chapter.
% lol

% \subsection{Third-Party Tools}
\section{Third-Party Tools}

What follows is a list of the third-party tools that were used in the
development of the project.
\begin{itemize}
\item Ubuntu Linux 10.04, Arch Linux 2010.05, Microsoft Windows 7
\item Clojure 1.2.0
\item Leiningen 1.6.1.1
\item OpenJDK 6
\item Seesaw 1.3.1-SNAPSHOT
\item swank-clojure 1.3.4-SNAPSHOT
\item GNU Emacs 23.1.1
\item A modified version of Overtone's Emacs configuration \cite{OvertoneEmacsD}, including:--
\begin{itemize}
\item SLIME/SWANK (revision as of 15/10/2009)
\item clojure-mode 1.11.5
\item undo-tree 0.3.3
\end{itemize}
\item Git 1.7.0.4
\item GitHub
\item Balsamiq Mockups
\item Google Docs
\item R 2.15.0
\end{itemize}

\section{Summary}

In this chapter, the work done in preparation for beginning the main
implementation of the project was detailed.  A thorough requirements analysis
has been conducted to outline the expected behaviour of the product,
contrasting it with the existing system of handwritten calculations.  In
\emph{Sec. 2.2}, prototype designs for a suitable graphical notation were
introduced.  Three in particular were explored in detail, before deciding on
the final notation upon which to base the project.  The next chapter contains a
detailed analysis of the work completed to implement the project.

\cleardoublepage
\chapter{Implementation}

This chapter details the implementation of the project.  The code itself totals
approximately 1,500 lines of Clojure, and the resultant application,
\emph{Nico}, satisfies the requirements laid out in the project proposal,
namely:--
\begin{center}
\parbox[c]{\textwidth-2cm}{
\small
``[to be] able to generate an abstract syntax tree in Clojure from the graphical language and evaluate such a tree, passing the results back to the graphical application and displaying this to user in less than 300ms.''
}
\end{center}
In addition to this, an extension to the project was completed, in the form of
a study that tested the software on real people.

\section{System Architecture}
% TODO: intro?

\emph{Nico} can be considered as having three distinct layers of operation: the user interface, the interaction handler and the back-end.  The user interface is what the user directly interacts with, with events in this layer being processed by the interaction handler, with the resultant data being passed to the back-end, which handles the mathematical and memory-management operations, to interpret.  Data can also flow in the other direction, with output from the back-end being passed up to the interaction handler to cause effects in the user interface.  An analysis of each layer in greater detail follows.

% TODO: sort out all the pictures, pdfxetex just can't handle that shit (i.e. scaling images - do it in gimp or something)
% TODO: overview of system architecture beforehand
\subsection{Back-End}
% calculations as data structures (lists to be evaled)
% rendering engine
% questions and marking
% question syntax
% questions as data structures (lists to be evaled)
% the fact that they are essentially answers means that answers can easily be compared to them, as well as manipulated and stuff - case in point, all the question-highlighting bullshit
% interactivity (300ms rule, see proposal for citation)
% very little mutable state
% placeholders?  why were they introduced?  how did they make things easier?  what problems did they solve?

% TODO: explain components rather than code, make it higher level
The application back-end handles the mathematical aspect of the application;
that is, it is able to interpret data gathered from the user's input and
process it as a calculation.  Each circle is represented by an associative map,
of the form \verb¬{:x 123 :y 234 :name "c0" :circ (+ 1 2 3 4)}¬, where the
\verb¬:x¬ and \verb¬:y¬ fields are numbers representative of the circle's
co-ordinates on the canvas, the \verb¬:name¬ field is a string used to refer to
the circle and the \verb¬:circ¬ field is an S-expression representative of the
calculation that the circle contains.  This S-expression can use any of five
operators: \verb¬+¬, \verb¬-¬, \verb¬*¬, \verb¬/¬ and finally \verb¬\?¬, a
placeholder for initialising circles.  Similarly, the arguments to the operator
can be either numbers or the placeholder character \verb¬\?¬.  A Clojure agent,
\verb¬used-circles¬,  stores a list of all the circles currently in use.

% list rather than paragraph?
% \emph{Nico's} back-end stores and manages circles and questions using five
% Clojure agents: \verb¬used-circles¬, containing a list of associative maps as
% detailed above, \verb¬current-qset¬, also containing a list of associative
% maps, this time representative of the questions to be answered (using a format
% of \verb¬{:n 1 :q (* 2 (+ 1 2 3) 7) :a? false :c? false}¬, where \verb¬:n¬ is
% the question number, \verb¬:q¬ is an S-expression representing the current
% question, and \verb¬:a?¬ and \verb¬:c?¬ are artefacts left over from a previous
% revision of the software, and are no longer used), \verb¬circle-number¬,
% containing an integer counting how many circles have previously been created
% whilst answering this question, \verb¬current-coords¬, which tracks the current
% co-ordinates of the mouse cursor, and \verb¬current-question¬, containing an
% integer indicating the number of the question currently being answered.

\emph{Nico's} back-end stores and manages circles and questions using just six
Clojure agents.  They are detailed below:
\begin{itemize}
\item \verb¬used-circles¬, containing a list of associative maps as detailed above
\item \verb¬current-qset¬, also containing a list of associative maps, this time representative of the questions to be answered, using a format of \verb¬{:n ¬\emph{n}¬\verb¬ :q ¬\emph{l}\verb¬ :a? false :c? false}¬, where \emph{n} is the question number, \emph{l} is an S-expression representing the current question, and the \verb¬:a?¬ and \verb¬:c?¬ fields are artefacts left over from a previous revision of the software, and are no longer used
\item \verb¬circle-number¬, containing an integer counting how many circles have previously been created whilst answering this question
\item \verb¬current-coords¬, which tracks the current co-ordinates of the mouse cursor
\item \verb¬current-question¬, containing an integer indicating the number of the question currently being answered
\item \verb¬currently-dragging-circle¬, which is used by the interaction handler to temporarily store information about circles that are currently being repositioned by the user
\end{itemize}

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/nico_backend.pdf}
\end{center}
% \caption{A rough model of \emph{Nico's} management of mutable state.}
\caption{A model of \emph{Nico's} management of mutable state; {\ttfamily currently-dragging-circle} is omitted as it is not utilised by the back-end.}
\end{figure}
\end{center}

\verb¬used-circles¬ is an agent containing a list of associative maps, as
detailed above.  \emph{Nico} includes two main functions for the management of
circles, namely \verb¬new-circle¬ and \verb¬del-circle¬.  \verb¬new-circle¬
creates an associative map initialised to the following values:
% TODO: also maybe talk about kill-used-circles

\begin{center}
\begin{figure}[H]
\begin{center}
\begin{minipage}{2.5in}% {\textwidth-2cm}
\begin{Verbatim}[fontsize=\small,numbers=left]
{:x (- (:x @current-coords) 50)
 :y (- (:y @current-coords) 50)
 :name (str "c" @circle-number)
 :circ (\? \? \?)}
\end{Verbatim}
\end{minipage}
\end{center}
\caption{The function {\ttfamily new-circle} initialises a circle centred on the current location of the mouse cursor, generating a name {\ttfamily "c}\emph{n}{\ttfamily "}, where \emph{n} is the number of circles that have previously been created and with an initial expression of {\ttfamily (\textbackslash? \textbackslash? \textbackslash?)}.}
\end{figure}
\end{center}

This map is then sent off to \verb¬used-circles¬.  The value of
\verb¬circle-number¬ is incremented by one, and the user-facing canvas area is
cleared and re-rendered.

\verb¬del-circle¬ is a more complex function that removes a circle from
\verb¬used-circles¬, taking either a string or two integers as its arguments.
If a string is passed to it, the function iterates across the contents of
\verb¬used-circles¬, reconstructing the list by \verb¬cons¬ing each element in
turn on to a new list.  If the \verb¬:name¬ field of the head of the
\verb¬used-circles¬ list matches the argument passed to \verb¬del-circle¬, the
function recurses without \verb¬cons¬ing that element on to the new list, thus
constructing a new version of the \verb¬used-circles¬ list with the desired
circle removed, which can then be sent off to the \verb¬used-circles¬ agent.
In the case that two integers (i.e. a pair of co-ordinates) is passed to
\verb¬del-circle¬, the function uses two extra local variables, \verb¬c¬ and
\verb¬c?¬, to determine which circle is being deleted.  To determine the value
of \verb¬c¬, the function calls \verb¬point-in-circle¬ on the provided
co-ordinates, which is another function that, if the co-ordinates are within
the boundaries of a circle, returns the \verb¬:name¬ field of that circle (or
\verb¬nil¬ otherwise).  \verb¬c?¬ tests whether or not \verb¬c¬ is equal to
\verb¬nil¬.  If \verb¬c?¬ has the value \verb¬false¬, then the co-ordinates
passed to \verb¬del-circle¬ are not in any circle, and hence nothing can be
deleted.  In this case, the function returns \verb¬nil¬.  In the case that
\verb¬c?¬ has the value \verb¬true¬, the function proceeds as if id had been
provided with a string rather than two integers, using the value of \verb¬c¬ as
the string to compare to.  Also included is a related function,
\verb¬kill-used-circles¬, that initialises \verb¬used-circles¬ to the empty
list.

To determine the current value of the user's calculation, two functions are
used: \verb¬find-root¬ and \verb¬eval-circle¬.

\verb¬find-root¬ finds the circle that is not used as an argument to any other
circle.  If there are two circles that match this criterion, \verb¬find-root¬
returns the first instance that it encounters; that is, the first instance of
a `root' circle.  As a complete calculation must only have one root circle
(else it would be two separate calculations), this is not problematic for
answer-checking.  However, it can be mildly confusing for the user if they are
constructing a calculation by constructing two subexpressions and merging them
at the end, and a future improvement to this design could be to find the root
of the calculation that the mouse is hovering over.  Regardless,
\verb¬find-root¬ works by iterating across \verb¬used-circles¬ and returning
the first circle that causes another function, \verb¬root?¬, to return the
value \verb¬true¬.  \verb¬root?¬ iterates across \verb¬used-circles¬, comparing
its single argument, a circle, to each of the other available circles in turn
using another function, \verb¬is-arg?¬, which takes the \verb¬:name¬ field of
its first argument and returns \verb¬true¬ if that name appears as a symbol
anywhere in the \verb¬:circ¬ field of its second argument.

\verb¬eval-circle¬ takes a circle as its argument and returns an S-expression
representative of the calculation that that circle represents, recursively
evaluating any circles that are contained within the argument circle.  It works
by iterating across the \verb¬:circ¬ field of its argument, \verb¬cons¬ing each
element on to a new list.  If an element is of type \verb¬clojure.lang.Symbol¬,
\verb¬eval-circle¬ calls \verb¬eval-circle¬ on the circle that the symbol
points to, which is resolved using a function \verb¬find-circle¬ that iterates
across \verb¬used-circles¬, trying to match each circle's \verb¬:name¬ field
against its argument.  \verb¬eval-circle¬ is then able to return a nested
S-expression that represents a calculation.  When used in conjunction with
\verb¬find-root¬, this function is able to resolve the entire diagram that has
been constructed on the canvas into a single S-expression, which can then be
evaluated or otherwise utilised as needed.

% TODO: centre this properly
\begin{center}
\begin{figure}[H]
\begin{center}
\begin{minipage}{8.2cm}% {\textwidth-2cm}
\begin{Verbatim}[fontsize=\tiny,numbers=left]
(defn eval-circle
  "Iterates across a circle list, resolving
   symbols into their respective circles."
  [circ]
  (loop [c (:circ (remove-placeholders circ))
         out '()]
    (cond (empty? c) (reverse out)
          (= (first c) \?) 0
          (symbol? (first c)) (cond
                                (nested?
                                  (find-circle
                                    (str
                                      (first c))))
                                  (recur (rest c)
                                         (cons (eval-circle
                                                 (find-circle
                                                   (str
                                                     (first c))))
                                               out))
                                :else (recur (rest c)
                                             (cons (:circ
                                                     (find-circle
                                                       (str
                                                         (first c))))
                                                   out)))
          :else (recur (rest c)
                       (cons (first c)
                             out)))))
\end{Verbatim}
\end{minipage}
\end{center}
\caption{The {\ttfamily eval-circle} source.}
\end{figure}
\end{center}

To manage the set of questions that the user is currently answering,
\emph{Nico} uses a function \verb¬read-qset¬ to load a set of questions from a
persistent file, exemplified in \emph{Fig. x.y} as \verb¬qset.nqs¬.
\verb¬read-qset¬ works by using the Clojure core function \verb¬slurp¬ to read
in the contents of the file indicated by the path provided as the argument to
\verb¬read-qset¬ as one long string.  The function \verb¬split-lines¬ provided
by the \verb¬clojure.string¬ library then separates each line of the string
into an element of a sequence.  \verb¬read-qset¬ then proceeds to iterate
across the sequence, prepending the string \verb¬"{:n ¬\emph{n}\verb¬ :q '"¬ and
appending the string \verb¬" :a? false :c? false}"¬ to each item in turn, where
\emph{n} is a counter starting with value 1 that is incremented with each
iteration.  This creates a valid specification for an associative map in
Clojure, so the Clojure core function \verb¬read-string¬ is called to evaluate
each item to a map, which is then \verb¬cons¬ed on to a list.  \verb¬read-qset¬
returns a list of question maps, which can then be sent off to the agent
\verb¬current-qset¬ to be presented to the user.  This method of loading a
question set requires that the file provided to \verb¬read-qset¬ must be a
plain text file containing one S-expression per line that represents the
question that the user is required to answer.  For my own testing files, I have
opted to use the file extension \verb¬.nqs¬ (\emph{Nico} Question Set) to make
it clear that these files are specifically for use as question sets.  A future
extension to this project could be to develop a partner application to
\emph{Nico} that allows tutors to more easily write their own question sets in
more familiar language, rather than requiring them to be aware of LISP syntax.
Due to time constraints, I decided not to write such an application as it was
outside of the stated goals of this project.

% TODO: talk about interesting problems with del-circle-safe, see logbook entries from 08/03/2012
% TODO: talk about defcircle

My original intention was that the creation of circles would be handled by a
macro, \verb¬defcircle¬,  that would allow circles to be `defined' in much the
same way as any other variable in Clojure, to be accompanied by another macro,
\verb¬letcircle¬, that would allow temporary circles to be locally defined
within the scope of a given function.  As the project progressed, it became
apparent that defining circles as variables was not useful, as actions
triggered from within the application (e.g. by pressing a button) were unable
to access the circles that had been defined in this way.  By this point in the
project I had already begun to monitor the co-ordinates of used circles using
an agent containing a list of maps, so it was a simple solution to use the same
agent, which could definitely be accessed at runtime, to contain the circle
maps instead.  I also had already written a function \verb¬new-circle¬ that was
calling \verb¬defcircle¬, so I decided to abandon \verb¬defcircle¬ and use
\verb¬new-circle¬ to initialise a map and send it off to \verb¬used-circles¬,
thus solving the problem.

I encountered some problems with the development of \verb¬del-circle¬ -- after
implementing the \verb¬del-circle¬ function described above, I noticed that
deleting circles that formed part of a chain would cause the application to
behave unexpectedly, being unable to render some circles properly and throwing
\verb¬java.lang.NullPointerException¬s.  This occurred due to the fact that
\verb¬del-circle¬ solely removed a circle, with no consideration of if it may
be being used as an argument to the expression represented by another circle.
As a result, the application began to throw exceptions as the now-invalid
references left behind were being followed by functions such as
\verb¬eval-circle¬, leading them to a non-existant location.  To combat this, I
developed a replacement function, \verb¬del-circle-safe¬, that deletes circles
in such a way that this problem does not occur.

\verb¬del-circle-safe¬ works by first checking if the circle being deleted is
used as an argument to any other circles, using a function \verb¬is-arg-of¬.
\verb¬is-arg-of¬ takes a circle map as an argument and returns a list of maps
showing which circles make use of the argument circle, essentially representing
the links in the diagram that the user sees.  The maps are of the format
\verb¬{:c ¬\emph{c}\verb¬ :a ¬\emph{l}\verb¬}¬, where \emph{c} is a string
containing the name of the circle that uses the argument circle and \emph{l} is
a list of integers indicating the indices of where the argument circle is used
in the list of arguments to \emph{c}.  To do this, \verb¬is-arg-of¬ iterates
across \verb¬used-circles¬, calling in each instance another function
\verb¬is-arg?¬, which returns \verb¬true¬ if its first argument (in this case
the argument of \verb¬is-arg-of¬) is used in the \verb¬:circ¬ field of its
second argument (in this case the current element of \verb¬used-circles¬).  If
this function returns \verb¬true¬, \verb¬is-arg-of¬ \verb¬cons¬es a new map on
to a list: the map consists of the \verb¬:name¬ field of the current element
of \verb¬used-circles¬ as the contents of the \verb¬:c¬ field, and constructs
the list to use for \verb¬:a¬ using another function, \verb¬arg-is¬, which uses
the \verb¬:name¬ field of its first argument and iterates across the
\verb¬:circ¬ field of its second, using a counter to construct a list of
indices where the first argument's \verb¬:name¬ appears as a symbol.  If
\verb¬is-arg-of¬ returns the empty list, then the circle is not used as an
argument anywhere and it is, therefore, safe to proceed as before, using the
same method of deletion that is used by the original \verb¬del-circle¬.  If
not, then the function iterates across the list that \verb¬is-arg-of¬ produces,
for each element retrieving the circle indicated by \verb¬:c¬, constructing a
list of indices using \verb¬arg-is¬ and constructing a new circle map in which
all instances of the circle being deleted have been replaced with placeholder
\verb¬\?¬ values.  \verb¬del-circle-safe¬ then calls itself on the circle that
uses the original circle to be deleted, thus removing all circles that formed
the chain that incorporated the original circle.  Finally, the function sends
the new circle (with the \verb¬\?¬ values) off to \verb¬used-circles¬ and
removes the original circle in the same manner as the unsafe version of
\verb¬del-circle¬; it is now safe to do so, as there are no longer any circles
that refer to the circle being deleted (their references having by now been
replaced with placeholder \verb¬\?¬ values).

This solved the problem of the leftover references to non-existant circles, but
it has also given rise to a new problem: due to the way that I have implemented
\verb¬del-circle-safe¬, and in particular due to the stage in which
\verb¬del-circle-safe¬ must call itself upon the other circles in the chain,
deleting a circle that forms part of a chain deletes all of the links between
the rest of the circles in the chain, from the circle being deleted down to the
root circle.  On reflection, a better way to implement safe deletion would have
been to include as part of the rendering loop a function to inspect
\verb¬used-circles¬, checking for any invalid references and replacing them
with \verb¬\?¬s.

\subsection{Interaction Handler}
% the bit that handles all the application shit: render, main-window, etc.
% talk about jfx2 vs. guiftw/swt vs. seesaw/swing
% talk about main-window here i guess?
% talk about dialogue boxes
%
% \emph{{\sc Note:} These paragraphs aren't in the correct order yet; I've just been writing things that I want to include in this subsection, and will reorder them when I have a better idea of where this bit's going.}

The interaction handler is a collection of functions that form the `middle
layer' of the application: that is, the functions that arbitrate between the
back-end and the user interface.

The function \verb¬render¬ plays a significant rôle in handling interaction.
This is the function that is called every time what is displayed on the canvas
needs to be updated.  It calls \verb¬clear-screen¬, which paints a white
rectangle over the canvas, followed by the bin icon, and then iterates across
\verb¬used-circles¬, calling a function \verb¬draw-circle¬ on each circle in
turn.  \verb¬draw-circle¬ determines what operation its argument circle uses,
and selects a colour scheme accordingly.  It then contains a sequence of paint
instructions that construct the circle on the canvas.  Finally, it calls
\verb¬draw-args¬, followed by \verb¬link-circles¬.  \verb¬draw-args¬ removes
the first element of its argument's \verb¬:circ¬ field and draws each of the
remaining elements at hardcoded co-ordinates relative to the \verb¬:x¬ and
\verb¬:y¬ values of the circle, with different sets of co-ordinates according
to how many arguments the circle has.  \verb¬link-circles¬ uses data from the
same sets of co-ordinates to determine which argument the user is trying to
replace with input from another circle, and draws a line from underneath the
source circle to the desired point on the destination circle, followed by a
small circle around that point to make it clear that this circle is receiving
the results of the other circle.

% TODO: should probably talk about highlighting, etc.

At the heart of the interaction handler is a structure called
\verb¬main-window¬.  \verb¬main-window¬ is what defines much of the user
interface: namely, the main window.  It controls what is displayed and the
actions to be performed under certain conditions, and listens for certain
events such as user input.

% TODO: maybe talk about lisp-to-maths?  no so much to say about the other panels than the canvas really though...

% TODO: diagram?  not sure how...  maybe like the one in the backend section?
% TODO: talk about agents relevant to this section like current-coords, currently-dragging-circle, etc.

Of particular note are the various listeners that monitor the canvas for mouse-
based events as part of \verb¬main-window¬.  As the mouse moves around the
canvas, \verb¬main-window¬ listens for a \verb¬:mouse-moved¬
event.\footnote{The Seesaw library refers to several events defined in
{\ttfamily java.awt.event.MouseEvent} in this way.  For example, a
{\ttfamily java.awt.event.MouseEvent.MOUSE\_CLICKED} is referred to as
{\ttfamily :mouse-clicked}, and a
{\ttfamily java.awt.event.MouseEvent.MOUSE\_RELEASED} is referred to as
{\ttfamily :mouse-released}.}  When this is detected (i.e. when the mouse is
moved), \verb¬main-window¬ calls an anonymous function that retrieves the
current co-ordinates of the mouse cursor, and calls a function
\verb¬point-in-circle¬, which compares a pair of co-ordinates to those of the
circles currently in \verb¬used-circles¬ to determine whether or not the mouse
is hovering over a circle.  \verb¬point-in-circle¬ returns the name of the
circle that the mouse cursor is currently over, or \verb¬nil¬ if it is not
currently over a circle.  The current co-ordinates of the mouse are sent off to
the agent \verb¬current-coords¬ in the form of a map,
\verb¬{:x ¬\emph{x}\verb¬ :y ¬\emph{y}\verb¬}¬.  The agent
\verb¬currently-dragging-circle¬ is also reinitialised to \verb¬nil¬, as mouse
motion without a button being held implies that no circle is currently being
dragged.  The canvas is then cleared using \verb¬clear-screen¬ and
\verb¬render¬, and in the case that \verb¬point-in-circle¬ does not return
\verb¬nil¬ at the current co-ordinates, the circle that the mouse is hovering
over is highlighted.  If \verb¬point-in-circle¬ returns \verb¬nil¬, the
question text is explicitly unhighlighted.

When \verb¬main-window¬ detects a \verb¬:mouse-clicked¬ event, it retrieves the
current co-ordinates of the mouse cursor, and tests for left-click, right-click
and Ctrl being pressed.  It also uses \verb¬point-in-circle¬ to return the
name, if any, of the circle that the mouse cursor is currently over, as well
as \verb¬arg-in-circle¬ and \verb¬op-in-circle?¬ to determine the index of the
argument, if any, that that mouse cursor is currently over by comparing the
current mouse co-ordinates to those of the predetermined placements of
arguments in each case of the circle having two to eight arguments, and whether
or not the cursor is over the circle's operator, again by comparing the current
co-ordinates to the predetermined placement of the operator relative to the
circle's co-ordinates.  It is also further determined whether or not the cursor
is currently over a placeholder argument, using the results of
\verb¬arg-in-circle¬.  This information is then used to implement \emph{Nico}'s
control scheme, as illustrated in \emph{Fig. x.y}.

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-4cm]{figs/nico_click.pdf}
\end{center}
\caption{Decision tree to determine the appropriate response to a {\ttfamily :mouse-clicked} event.}
\end{figure}
\end{center}

In the case that the cursor is not over a circle, \verb¬new-circle¬ is called,
with the current co-ordinates as arguments, creating a blank circle, as
described in the previous section.  If the cursor is over a circle and the
mouse has been right-clicked, the circle is removed from \verb¬used-circles¬
and a new version is sent off, either with its final argument removed or with a
placeholder argument added.  In the case that the user tries to remove an
argument when there are only two, or to add an argument when there are already
eight, an alert box appears, warning the user that they are only allowed a
minimum of two and a maximum of eight arguments.

If the mouse is over a circle, has been left-clicked and is over one of the
circle's arguments, \verb¬main-window¬ draws a small blue circle around the
argument and launches a dialogue box using the function
\verb¬mod-arg-dialogue¬, which defines a simple window containing a spinner
and returns the contents of that spinner upon the user pressing the {\sfapp OK}
button.  The circle that had been clicked originally is then removed from
\verb¬used-circles¬, and replaced with a version in which the chosen argument
has the value that the user has input.  \verb¬clear-screen¬ and \verb¬render¬
are called, and the answer displayed at the top of the application is updated
by using \verb¬find-root¬ to find the root circle of the diagram, and then
re-evaluating the entire expression.  The process is similar in the case that
the mouse was over a circle's operator, except that the function
\verb¬mod-op-dialogue¬, which defines a small dialogue box containing four
radio buttons corresponding to the four arithmetic operations and returns the
user's selection, is called, rather than \verb¬mod-arg-dialogue¬.

\emph{Nico}'s drag-and-drop functionality is also implemented using
\verb¬main-window¬'s listeners.  When a \verb¬:mouse-pressed¬ event is
detected, the mouse co-ordinates are once again retrieved and
\verb¬point-in-circle¬ is called.\footnote{{\ttfamily :mouse-pressed} is not
the same as {\ttfamily :mouse-clicked}.  The latter only occurs when the mouse
is pressed {\bf and then} released, whereas the former occurs every time the
mouse button is pressed.  It is for this reason that the actions that occur
when {\ttfamily :mouse-clicked} is detected must reinitialise
{\ttfamily currently-dragging-circle} to {\ttfamily nil}.}  If
\verb¬point-in-circle¬ does not return \verb¬nil¬, the circle map that
corresponds to the name returned is sent off as part of a map to the agent
\verb¬currently-dragging-circle¬.  This map takes the form
\verb¬{:c ¬\emph{c}\verb¬ :t ¬\emph{t}\verb¬ :m ¬\emph{m}\verb¬}¬, where
\emph{c} is the circle map, \emph{t} is the current system time in milliseconds
and \emph{m} is the integer representing the mouse button that was pressed.
When the application detects a \verb¬:mouse-dragged¬ event, this information is
then used to determine which action to take.  First,
\verb¬currently-dragging-circle¬ is checked.  If it is \verb¬nil¬, no action
needs to be taken.  To check that the user has deliberately dragged the mouse,
the current system time is compared to the \verb¬:t¬ value in
\verb¬currently-dragging-circle¬'s map.  If the difference is greater than
100ms, this is determined to be an intentional mouse drag, and the function
proceeds.  If the left mouse button is pressed, the mouse co-ordinates are
compared to the location of the bin icon.  If the circle has been dragged into
the bin area, it is removed.  Otherwise, it is relocated to the current
position of the mouse cursor by removing it from \verb¬used-circles¬ and
sending off a version with the \verb¬:x¬ and \verb¬:y¬ fields modified
appropriately.  If the right mouse button is held, a line is drawn from the
circle to the current location of the mouse, and a circle is also drawn around
this point.  If the mouse is dragged on to an argument that is not in the
source circle, the line and circle are anchored in that argument's slot and the
target circle is removed from \verb¬used-circles¬, being replaced by a version
with the appropriate argument modified to be a symbol referring to the source
circle.
% do i need to mention *all* the times clear-screen and render are called?  it's kind of implicit (to me anyway)...

As mentioned above, \emph{Nico} has the ability to highlight sections of the
question currently being answered that correspond to circles or sets of circles
within the user's diagram.  This is achieved using a function \verb¬highlight¬,
which uses a function \verb¬lisp-to-maths¬ to convert S-expressions into
standard mathematics.  \verb¬lisp-to-maths¬ uses a counter beginning with value
0 to append the operator of an S-expression on to a string of its arguments
every time the counter is odd, producing the infix expressions many people are
more comfortable with.  When the counter is not odd, if the next argument is a
list, \verb¬lisp-to-maths¬ recursively calls itself on that list, appending to
the string being produced the string \verb¬"("¬, the output of the recursive
call to \verb¬lisp-to-maths¬ and the string \verb¬")"¬, creating a more
familiar-looking subexpression using brackets.  If the counter is not odd and
the current element of the S-expression is not a list, the element is simply
appended to the string being created.  This produces a line of mathematics from
an S-expression; for example, an input of \verb¬(+ 1 2 (* 3 4) 5 (- 6 7) 8)¬
will produce an output of \verb¬"1+2+(3×4)+5+(6-7)"¬.  This function is also
used to produce the contents of the {\sfapp Question} panel from the questions
contained in the question set file.  \verb¬highlight¬ uses \verb¬lisp-to-maths¬
to compare the question string to the translation of a circle into regular
mathematics using another function \verb¬detect-subs¬, which takes two strings
as arguments and returns a list of maps containing the start and end indices of
every instance where the first argument appears as a substring of the second
argument.  \verb¬detect-subs¬ iterates across its second argument, character by
character, using a counter that is incremented by one with each iteration to
compare its first argument to the substring of its second that begins at the
current value of the counter and ends at the same value, plus the length of the
substring being searched for.  If it detects that those two strings are equal,
the start and end indices are put into a map and appended to a list.
\verb¬highlight¬ iterates across the resultant list of \verb¬detect-subs¬, and
changes the colour of the text that matches the result of calling
\verb¬lisp-to-maths¬ on the result of evaluating a circle.

\begin{center}
\begin{figure}[H]
\begin{center}
\subfloat[]{\includegraphics[height=\textwidth/3-1cm]{figs/nico_hi1.png}}
\subfloat[]{\includegraphics[height=\textwidth/3-1cm]{figs/nico_hi2.png}}
\\
\vspace{0.5cm}
\subfloat[]{\includegraphics[height=\textwidth/3-1cm]{figs/nico_hi3.png}}
\end{center}
\caption{Three instances of the question text being highlighted as a corresponding circle is moused-over.}
\end{figure}
\end{center}

% TODO: more!  this shouldn't be the first (or last) paragraph in this section
% TODO: depersonalise
The original intention of the project was to develop \emph{Nico} using the JavaFX library.
However, a number of difficulties were encountered with this: firstly, JavaFX
version 2.0 was not available for Linux, the primary development environment, at
the time of beginning the project.  Installation was attempted on a
Windows machine, but caused a number of problems. In the interest of making progress, it was decided to proceed
using the Eclipse Foundation's SWT toolkit and Szymon Witamborski's
corresponding Clojure bindings, GUI FTW! \cite{GuiFtw}.  During the development of the user interface, many problems were encountered with SWT and GUI FTW!, particularly regarding drawing
arbitrary shapes on the canvas area and extracting user input from
dialogue boxes.  To keep the project on-schedule, the application was migrated to Java Swing,
using David Ray's Seesaw library to provide bindings for
Clojure \cite{Seesaw}.

%
% \emph{{\sc Note:} This is as far as I've got (about halfway by my reckoning).  }\verb¬texcount¬\emph{ tells me I've got about 5,800 words.}

% \subsection{User Interface}
% do we even need this section?  applciation below might cover it, and to be fair it isn't really part of the architecture - listeners and that should probs go in interaction handler above
%
\section{User Interface}%{Application}
% application in which the language is manipulated
% talk about how the app has changed, show screenshots
% talk about how the app becamse more minimalist, to focus on the language itself
% language as a main focus, with useful information n shit around it in the app
% colour-coding text (though consider colour-blindness with the red and green text)
% question highlighting - talk about troubles with it, but also merits of including it
% do we need this section?  shouldn't this be the ui bit in the prev. section?
% have lost the ui bit in favour of having this as a separate section
% target audience - children (year 5), but also applications in remedial adult learning (i.e. can't be too childish)
% hence must be appealing, clear, easy-to-read, not too verbose
% prototypes! take screenshots of old versions

The user interface comprises the parts of the application which are
user-facing; that is, they are that which the user directly interacts with.
The development of \emph{Nico}'s user interface was key to the success of the
overall project, being primarily an experiment in human-computer interaction.

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{figs/nico_screen_01.png}
\end{center}
\caption{A screenshot of a \emph{Nico} session.}
\end{figure}
\end{center}

The application itself was kept fairly minimal: the aim was to emphasise the
notation as the most important aspect of the software.  As such, the main
application window, as shown above in \emph{Fig. x.y}, is mostly dedicated to
the canvas area in which the user answers the question.  The main application
window is split up into two main sections, the information panels that display the question being answered and the current
total of the user's calculation, as well as the {\sfapp Check} button to submit
the current total as the answer, and the large canvas
area in which the user is able to construct diagrams with which to answer the
question.

% TODO: diagram?  like the one in the notebook, showing the consequences of each possible action to illustrate the control scheme and notation

% why the '(\? \? \?) initial circle expr?
\emph{Nico} uses a predominantly mouse-based control system for the
construction of calculations in the application's notation.  Left-clicking on a
blank patch of canvas creates a new circle, initialised with two arguments,
{\sfapp ?} and {\sfapp ?}, and with operator {\sfapp ?} -- this approach was chosen, rather than providing the user with a null circle such as (0+0), to make it clear to the user that the new circle required attention, and so that it wouldn't interfere with the evaluation of the diagram; a new circle on its own could be found to be a root circle, leading to the possibility that the user's total could suddenly drop to 0, which would be confusing.  Right-clicking on a
circle increments its number of arguments by one, up to a maximum of eight.
Holding the Ctrl key and right-clicking on a circle decrements its number of
arguments by one, down to a minimum of two.  The user is warned by a popup if the exceed either of these boundaries.  The limit of two to eight arguments was decided upon as fewer than two arguments is an unfamiliar and not often useful concept from the perspective of the target audience.  Although Clojure is able to evaluate, for example, \verb¬(+ 1)¬ (returning \verb¬1¬), this is liable to lead to confusion on the part of the user.  The upper limit of eight arguments was set to prevent circles from becoming overcrowded and harder to read.
Circles can be moved around the
canvas by left-clicking and dragging the circle to the desired location.  If a
circle is dragged to the bin icon in the bottom left-hand corner of the screen,
then it is removed.  Originally, deletion was mapped to a mouse control, but in the interest of a simpler control scheme and with a limited number of mouse buttons, it was decided that an icon should be used instead.  This also has the advantage of demonstrating to the new user that work can be easily undone, encouraging exploration.  Left-clicking on a circle's operator brings up a dialogue
box with a selection of operators in it, with a radio button for each (see
\emph{Fig. x.y}).  Similarly, left-clicking on a circle's argument brings up a
dialogue box containing a spinner, which can be used to set a new value for
that argument, between -10 and 10.  The spinner is limited to this particular
range as this prevents the user from effectively using the software as a simple
calculator.  The limited range of numbers available means that the user must
still consider strategies such as partitioning or long multiplication,
focussing on how to solve the problem, rather than simply transcribing the
question into one circle that will complete the calculation for them.  The user is not required to calculate manually expressions using such small numbers, as it is assumed that the target audience are familiar with simple arithmetic.  To use
one circle as an argument to another, right-clicking and dragging allows the
user to drag a line ending in a circle to the desired slot on the recipient
circle.

\begin{center}
\begin{figure}[H]
\begin{center}
\subfloat[Editing a circle's operator]{
\includegraphics[width=\textwidth/2-2cm]{figs/nico_op.png}
}
\subfloat[Editing a circle's argument]{
\includegraphics[width=\textwidth/2-2cm]{figs/nico_arg.png}
}
\end{center}
\caption{The dialogue boxes used to modify existing circles in the application.}
\end{figure}
\end{center}

% talk about colour-blindness
% why this colour scheme? psychological reasons?
% why not random or connection-based colours?
\emph{Nico} also uses colour-coding in various areas of the application, to
draw attention to important elements of the application.  Colour-coding has
been shown to faciliate more effective learning.  Indeed, Lamberski and Dwyer
note that
\begin{center}
\parbox[c]{\textwidth-2cm}{
\small
``[...] younger learners, for whom color in passive materials has been found to facilitate performance in less complex concept attainment tasks because of color's attention of motivation elements.  However, when younger learners have been given self-paced instructional materials containing color-coded reading and phonic concepts, similar positive results have been attained.'' \cite{Lamberski1983}
}
\end{center}
Circles are coloured according to their operators, clearly separating different
kinds of operations and making the notation more readable.  An alternative
method of colour-coding by the level of nesting was considered, but rejected on
the grounds that it could become confusing if a circle were reused (see
\emph{Fig. x.y}).

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/nico_screen_02.png}
\end{center}
\caption{An example of where nesting-based colour-coding would be confusing.  The circle containing (2+2) can be considered to be both one and two circles removed from the root circle.}
\end{figure}
\end{center}

Colour-coding is also used in the information panels: positioning the mouse cursor over a circle highlights the part of
the question that it is likely to represent in blue, and also highlights the
circle with a blue outline.  When an answer is submitted, the text in the
answer panel turns red if the answer was incorrect, or green if the answer was
correct, providing an unintrusive form of feedback, allowing the user to
continue uninterrupted (i.e. no input is required) if their answer is wrong.

\begin{center}
\begin{figure}[H]
\begin{center}
\subfloat[Red text indicates that the answer submitted was incorrect]{
\includegraphics[width=\textwidth/3]{figs/nico_wrong.png}
}\hspace{2cm}
\subfloat[Green text indicates a correct answer; a dialogue box allows the user to progress to the next question when they are ready]{
\includegraphics[width=\textwidth/3]{figs/nico_right.png}
}\\
\subfloat[The circle's operator is highlighted when it is being edited]{
\includegraphics[width=\textwidth/3]{figs/nico_op_hi.png}
}\hspace{2cm}
\subfloat[An argument is highlighted when it is being edited]{
\includegraphics[width=\textwidth/3]{figs/nico_arg_hi.png}
}
\end{center}
\caption{Examples of colour-coding in \emph{Nico}.}
\end{figure}
\end{center}

During its development, \emph{Nico}'s user interface went through a number of
revisions.  Details of how the UI design developed over time follow.

\subsubsection{First Revision}
Initially, the application was intended to use more buttons (see
the prototype in \emph{Fig. x.y}, above), having more controls immediately
visible to the user.  In the first usable version of the interface, there were
a number of buttons that appeared down the side of the application.  Each
button ({\sfapp New}, {\sfapp Edit}, {\sfapp Delete}, etc.) would cause a
dialogue box to appear to the user, which required a circle to be specified by
name (at this point in the development of the project, it was required that the
user name each of their circles) before any operations could be performed upon
it.  Circles were all the same colour, and the text-highlighting and
colour-coding operations had not yet been implmented.  It was also the case
that the links between circles did not end in argument slots, but rather fed
into the centre of the target circle.  This design was abandoned as the
separation between the user and the diagram itself was too great; creating
circles by specifying options in many only slightly different dialogue
boxes and watching the results appear on the canvas did not feel like a natural
way to interact with one's calculation, and hence would have been inappropriate
for the target audience.  The intention of the project is not to require the
user to spent a significant amount of time learning how to use the system
before it becomes a useful tool to them.
% how did we know the separation was too great?
% avoid "similar-but-slightly-different"

\subsubsection{Later Revisions}
Later revisions of the software removed the buttons and implemented a system of
context menus with which to construct answers. Right-clicking on a blank patch
of the canvas gave the user the option to create a new circle, and right-
clicking on an existing circle presented the user with the option to either
edit or delete that circle.  Choosing to either create of edit a circle
displayed a dialogue box (\emph{Fig. x.y}), with many options for the user to
choose from: the name and operator of a circle could be set, with up to eight
arguments could be enabled, with a choice of either a number (set by a slider)
or another circle (chosen using a list of radio buttons that was generated upon
opening the dialogue box) as the value of that argument.  Answer-checking was
also made automatic: as soon as the total reaches a value equal to that of the
answer to the question, the user is immediately told so, and moved on to the
next question.  The circles at this point are still one colour only, and there
is no expression-highlighting.  The colour-coded totals had been implemented by
this point.  This design was ultimately abandoned  as, again, it separated the
user from their own work too much.  Although this design was an improvement,
allowing the user to interact directly with the canvas to perform operations
upon circles that were able to specified by pointing with the mouse, rather
than by typing out a name, the grand unified dialogue box still required the
user to perform operations without it being entirely obvious what the
consequences would be, thus requiring an unnecessary amount of
\emph{premature commitment} from the user.  The automatic answer-checking was
also a problem, as it did not give the user a chance to review their answer
before proceeding.  Indeed, it did not give the user a chance to learn from
their mistakes, say for example if they had accidentally reached the right
answer as part of a larger, incorrect calculation that they had previously
intended to make.

\subsubsection{Current Revision}
The final, current revision of the software reintroduces the {\sfapp Check}
button to address the issues with the automatic answer-checking in the
previous version of the application.  It also introduces the control scheme
detailed above, allowing the user to feel more like they are directly
manipulating their work in progress, with each action having clear
consequences.  A colour scheme for the circles was implemented, to make the
notation easier to read, and the expression-highlighting functionality was also
introduced, along with the other means of highlighting, as shown above.
Finally, the bin icon was introduced after deciding that a control for deletion
was not an ideal approach, as detailed above.

\begin{center}
\begin{figure}[H]
\begin{center}
{\Huge \sfapp OLD VERSIONS OF THE APP LOL}
\end{center}
\caption{\emph{Nico}'s user interface went through a number of revisions before reaching its current state.}
\end{figure}
\end{center}

\subsection{Notation}%metaphor?
% graphical language itself
% show previous versions
% talk about how the circles have to make clear e.g. arg order
% talk about how circles had to be improved, show iterations
% more screens: old versions of the language to compare

\begin{center}
\begin{figure}[H]
\begin{center}
{\Huge \sfapp OLD VERSIONS OF THE NOTATION LOL}
\end{center}
\caption{The notation used also went through a number of revisions before reaching its current state.}
\end{figure}
\end{center}

The notation itself was also revised several times during the development of
the application.  The original vision of the notation can be seen in
\emph{Fig. x.y}.  The first implementation of the notation consisted of
uniformly-coloured circles connected by lines feeding into the centre of the
recipient circle.  There were no placeholder values; these were unnecessary as
the system of dialogue boxes meant that at no point could a circle have any
aspect of itself in an undefined state.  There was also no indication of
argument ordering, which is acceptable when the operator is commutative (i.e.
addition or multiplication), but for operations where this is not the case,
this can quickly become confusing.  Although the ordering and placement of
arguments was defined, with no indication of this, the user is required to
figure this out through experience, which is counter to the intentions of the
software.  As mentioned above, it should not be required that the user spend a
significant amount of time learning how to use the system, especially due to
deficiencies in the notation.  Another, greater, problem related to argument
ordering was that of the circles that linked to other circles.  With all input
circles pointing to the operator at the centre of their target circle, it was
not at all clear in which order the input circles evaluated, neither relative
to each other nor to the other arguments in the circle.

% TODO: poss. a figure showing close-ups/details of newest notation?

The notation changed somewhat to address the problems listed above.  In its
current revision, the notation has had a number of features added.  Firstly,
the circles are now colour-coded by operator, making it easier for the user to
distinguish between different kinds of circles.  The circles themselves have
also been embellished slightly with the addition of a line denoting the star of
the expression, just to the side of the first argument at the top of the
circle.  Smalls arrow have also been added to the edge of the circles to
indicate in which direction the arguments should be read.  Finally, the links
between circles have been changed such that they now occupy an argument slot
that could otherwise be taken by a number, with a circle on the end of the link
line to clearly show where the link terminates.
% TODO: more cogdims!  ALWAYS more cogdims!

% TODO: testing?  or does that go in the next chapter?

\section{Summary}

In this chapter, the implementation of the project was discussed in some
detail, as well as the challenges that were faced during this development
phase.  The software itself fulfils and exceeds the criteria for success
outlined in the project proposal, being a complete and usable system that
improves greatly, in terms of cognitive dimensions, upon the traditional method
of handwritten arithmetic.  Third-party libraries, in particular Seesaw, were
used where appropriate.  The application divides into three main sections: the
back-end, handling mathematical operations and memory management, the
interaction handler, helping the user interface to interface with the back-end,
and the user interface itself.  The user interface was revised many times to
correct deficiencies in the design that would have led to a poor user
experience, and the back-end and interaction handler were also both restructured
as new demands upon the software became apparent.

In the next chapter, the software will be evaluated, discussing test results
and the user study that was conducted as an extension to the project.

\cleardoublepage
\chapter{Evaluation}

This chapter concerns the testing and evaluation of \emph{Nico}; carried out to determine the quality and utility of the software.

\section{Testing}% {Defect Management and Testing}% {Backend Testing}
% used slime/swank with test lines as comments to be evaluated with C-x C-e
% emacs/slime/swank as ide; ideal for lisps!
% lein test framework - need to actually set up some tests first though!
% clojure test-is; see http://en.wikibooks.org/wiki/Clojure_Programming/Tutorials_and_Tips#Unit_Testing_in_Clojure

% does C-x C-e *actually* count as unit testing?  i mean, i *did* test small bits and then test bigger bits after i'd established that the smaller bits worked...
% apparently it does! w00t
% also talk about integration testing (after the units have been tested, testing the bits that use those units), and see the link in alistair's email re other levels of testing
Throughout the development of the software, I performed unit tests to ensure
the integrity of my code.  My development environment of choice, GNU Emacs
using SLIME/SWANK and clojure-mode, includes functionality such that
commented-out lines of code can be evaluated at will.  As such, it was possible
for me to write unit tests into the main body of my code, evaluating them
whenever a change may have affected how a function behaved.  In the interests
of tidiness and code readability, many tests were removed as they became
unnecessary later on in the devlopment in the project, but \emph{Fig. x.y}
shows one of the test blocks that were left in the most recent revision of the
source code.

\begin{center}
\begin{figure}[H]
\begin{center}
\begin{minipage}{11.7cm}% {\textwidth-2cm}
\begin{Verbatim}[fontsize=\tiny,numbers=left]
(defn detect-subs
  "Returns a list of maps containing start and end indices showing where a substring c appears in the superstring q."
  [c q]
  (loop [s (cond (= (subs q
                          (- (count q) (count c))
                          (count q)) c) (split q
                                               (re-pattern
                                                (escape
                                                 c
                                                 {\+ "\\+"
                                                  \( "\\("
                                                  \) "\\)"})))
                 :else (butlast (split q
                         (re-pattern
                          (escape
                           c
                           {\+ "\\+"
                            \( "\\("
                            \) "\\)"})))))
         i 0
         l '()]
    (cond (empty? s) (reverse l)
          (= c (subs q
                     (+ i (count (first s)))
                     (+ i (count (first s)) (count c)))) (recur (rest s)
                                                                (inc i)
                                                                (cons {:s (+ i (count (first s)))
                                                                       :e (+ i (count (first s)) (count c))}
                                                                      l))
          :else (recur s (inc i) l))))

;; (def tq (lisp-to-maths (eval (:q (first @current-qset)))))
;; (subs tq (:s (nth (detect-subs "1+2" tq) 0)) (:e (nth (detect-subs "1+2" tq) 0)))
;; (subs tq (:s (nth (detect-subs "1+2" tq) 1)) (:e (nth (detect-subs "1+2" tq) 1)))
;; (subs tq (:s (nth (detect-subs "1+2" tq) 2)) (:e (nth (detect-subs "1+2" tq) 2)))
;; (let [s "roflolmaomglolwtf" i (detect-subs "lol" s)] (subs s (:s (nth i 0)) (:e (nth i 0))))
;; (let [s "roflolmaomglolwtf" i (detect-subs "lol" s)] (subs s (:s (nth i 1)) (:e (nth i 1))))
;; (let [s "roflolmaomglolwtf" i (detect-subs "lol" s)] (subs s (:s (nth i 2)) (:e (nth i 2))))

;; (let [s "0123456789" i (detect-subs "456" s)] (subs s (:s (first i)) (:e (first i))))
;; (let [s "roflolmaomglolwtf" i (detect-subs "lol" s)] (subs s (:s (first i)) (:e (first i))))
;; (let [s "fagaha" i (detect-subs "a" s)] (subs s (:s (first i)) (:e (first i))))
;; (let [s "lalala" i (detect-subs "a" s)] (subs s (:s (first i)) (:e (first i))))
;; (detect-subs (lisp-to-maths (eval-circle (find-circle "c0"))) (lisp-to-maths (eval (:q (first @current-qset)))))
;; (let [s "dcbabcd" i (detect-subs "a" s)] (subs s (:s (first i)) (:e (first i))))
;; (let [s "dcbabcd" i (detect-subs "a" s)] (subs s (:s (nth i 1)) (:e (nth i 1))))

\end{Verbatim}
\end{minipage}
\end{center}
\caption{An example of a block of inline tests, taken from {\ttfamily core.clj}, showing some tests to be run to test the implementation of {\ttfamily detect-subs}.}
\end{figure}
\end{center}


\section{UI Evaluation}
% user testing
% graphs

\subsection{Notation Evaluation}
% user testing
% graphs

\section{User Study}
% results
% pilot study - ellie suggested switching left/right-clicks in control scheme, implemented before main study

To assess the utility of the software relative to handwritten arithmetic, a
user study was conducted, allowing real users to get to grips with the system,
and provide feedback on it.  To this end, users were given a tutorial video and
a questionnaire (see \emph{Appendix A} for the full questionnaire) to complete
whilst using the software.

Originally, it was the intention of this project to perform a user study upon
a `test class' of Year 5 pupils at an actual school, but the ethical
complications involved with working with vulnerable individuals were so great
as to make such a study impractical, given the time constraints of this
dissertation; in addition to obtaining the approval of the Ethics Committee and
the permission of a school to conduct the study, consent forms would have to be
distributed to the test class, taken home, signed by the pupils' guardians,
returned to the school and returned to myself.  It was, therefore, decided that
the software should be tested upon a group of students not currently reading a
`mathematical' subject, such as the Natural Sciences Tripos, the Mathematical
Tripos or the Computer Science Tripos, which necessitate a high level of
mathematical aptitude and experience.

Test subjects were first asked to sign a statement of informed consent, giving
their consent to participate in the study, and were then asked if they had
previously used \emph{Nico}, and to indicate their confidence in their ability
to solve simple mathematical problems on a five-point Likert item.  Users were
then divided into two groups.  The first watched the tutorial video and were
allowed to explore the application in a `sandbox' environment for five
minutes.  They then completed one question set using \emph{Nico}, and answered
the same questions by hand.  The second group completed the questions by hand
before watching the video and using the software.  The time taken to answer
each question was recorded, with \emph{Nico} including functionality to query
the system time as the user progressed and the handwritten questions being
timed using a stopwatch.  Both groups were then asked to complete a series of
questions to provide feedback on the software, taking questions from Blackwell
and Green's sample questionnaire. \cite{Blackwell2000}

\subsection{Pilot Study}
% changes, improvements

A pilot study was conducted with one test subject, to assess the feasibility of
the experiment that had been designed.  The outcome of this study was to make
changes to several areas of the test, and a small change to the control scheme
of the application itself.  Firstly, the pilot test subject noted that the
original version of the tutorial video for \emph{Nico} was hard to follow; it
used subtitles to convey information, which the test subject felt were hard to
read and understand in the time given.  The subject also noted that some of the
questions in the feedback section were confusing or seemingly irrelevant to
this particular application, and was unsure of how to answer them.  The final
piece of feedback that the subject provided was that the control scheme of the
application seemed counterintuitively focussed upon the right mouse button,
where it would have felt more natural to the user to have used the left.

In the interests of improving the study, I acted upon the subject's advice.
The video was reproduced using a voiceover rather than subtitles, making it
easier to follow.  Some of the less relevant questions were removed from the
feedback section, leaving those more applicable to \emph{Nico}.  Finally, the
control scheme was revised, assigning the left mouse button to primary
functions such as the creation and editing of circles, and the right to
functions such as changing the number of arguments.

\subsection{Results}
% data, graphs, analyses
% p-values:
% q1:  t = -8.0204, df = 7, p-value = 8.968e-05 <- sig
% q2:  t = -8.0493, df = 7, p-value = 8.764e-05 <- sig
% q3:  t = -8.9296, df = 7, p-value = 4.489e-05 <- sig
% q4:  t = -2.9592, df = 7, p-value = 0.02113   <- sig
% q5:  t = -5.288, df = 7, p-value = 0.001138   <- sig
% q6:  t = -1.3149, df = 7, p-value = 0.2300
% q7:  t = 2.3688, df = 7, p-value = 0.0497     <- sig
% q8:  t = 3.1, df = 7, p-value = 0.01732       <- sig
% q9:  t = 4.0293, df = 7, p-value = 0.005      <- sig
% q10: t = 2.1298, df = 7, p-value = 0.0707

The results of the tests are shown in \emph{Table x.y}, listing the times taken
for each subject to answer the questions both by hand and using \emph{Nico}.

\begin{center}
\begin{table}[H]
\begin{center}
\begin{tabular}{|r||r|r||r|r||r|r||r|r|}
\cline{2-9}
\multicolumn{1}{c|}{} & \multicolumn{8}{c|}{Group 1}\\ \cline{2-9}
\multicolumn{1}{c|}{} & \multicolumn{2}{c||}{Subject 1} & \multicolumn{2}{c||}{Subject 2} & \multicolumn{2}{c||}{Subject 3} & \multicolumn{2}{c|}{Subject 4}\\ \hline
\multicolumn{1}{|c||}{Question} & \multicolumn{1}{c|}{Hand} & \multicolumn{1}{c||}{\emph{Nico}} & \multicolumn{1}{c|}{Hand} & \multicolumn{1}{c||}{\emph{Nico}} & \multicolumn{1}{c|}{Hand} & \multicolumn{1}{c||}{\emph{Nico}} & \multicolumn{1}{c|}{Hand} & \multicolumn{1}{c|}{\emph{Nico}}\\ \hline \hline
Q1 & 4600 & 19547 & 3100 & 34094 & 1800 & 24657 & 1300 & 38891\\ \hline
Q2 & 8800 & 23313 & 7000 & 24329 & 6300 & 17437 & 5400 & 12031\\ \hline
Q3 & 20600 & 53500 & 13600 & 36360 & 10100 & 40798 & 10700 & 31813\\ \hline
Q4 & 36200 & 54375 & 26400 & 60156 & 14200 & 79704 & 23800 & 50094\\ \hline
Q5 & 61900 & 103344 & 39600 & 79844 & 26500 & 103221 & 33400 & 61064\\ \hline
Q6 & 213400 & 224406 & 190300 & 215376 & 84900 & 172940 & 181700 & 154691\\ \hline
Q7 & 235200 & 165813 & 1996000 & 103376 & 909000 & 48922 & 194200 & 52595\\ \hline
Q8 & 259500 & 306625 & 282500 & 158094 & 147200 & 138581 & 256700 & 155347\\ \hline
Q9 & 304400 & 230953 & 313500 & 123626 & 159800 & 183722 & 271700 & 196144\\ \hline
Q10 & 416500 & 307734 & 357700 & 213642 & 197100 & 245161 & 322200 & 235364\\ \hline
\multicolumn{9}{c}{}\\ \cline{2-9}
\multicolumn{1}{c|}{} & \multicolumn{8}{c|}{Group 2}\\ \cline{2-9}
\multicolumn{1}{c|}{} & \multicolumn{2}{c||}{Subject 1} & \multicolumn{2}{c||}{Subject 2} & \multicolumn{2}{c||}{Subject 3} & \multicolumn{2}{c|}{Subject 4}\\ \hline
\multicolumn{1}{|c||}{Question} & \multicolumn{1}{c|}{Hand} & \multicolumn{1}{c||}{\emph{Nico}} & \multicolumn{1}{c|}{Hand} & \multicolumn{1}{c||}{\emph{Nico}} & \multicolumn{1}{c|}{Hand} & \multicolumn{1}{c||}{\emph{Nico}} & \multicolumn{1}{c|}{Hand} & \multicolumn{1}{c|}{\emph{Nico}}\\ \hline \hline
Q1 & 1200 & 22299 & 2100 & 23516 & 2600 & 16142 & 2600 & 21985\\ \hline
Q2 & 2200 & 24530 & 5600 & 19015 & 7200 & 16875 & 7200 & 23422\\ \hline
Q3 & 17300 & 47620 & 7600 & 29735 & 18400 & 27923 & 15900 & 48470\\ \hline
Q4 & 23000 & 50704 & 20700 & 43094 & 25300 & 37516 & 38600 & 174160\\ \hline
Q5 & 46600 & 134828 & 33300 & 70313 & 35500 & 58954 & 72400 & 98846\\ \hline
Q6 & 199900 & 629835 & 136400 & 164891 & 99000 & 113659 & 266600 & 252708\\ \hline
Q7 & 202400 & 80277 & 142200 & 48890 & 1106000 & 52954 & 272900 & 72767\\ \hline
Q8 & 295900 & 248736 & 182000 & 107375 & 184700 & 78001 & 348900 & 257224\\ \hline
Q9 & 312900 & 152185 & 204100 & 118594 & 200500 & 67485 & 384500 & 144753\\ \hline
Q10 & 357300 & 238300 & 261600 & 203110 & 237500 & 324581 & 472900 & 270177\\
\hline
\end{tabular}
\end{center}
\caption{Table showing the time in milliseconds taken by each test subject to complete each question, by hand and using the software.}
\end{table}
\end{center}

This data can be visualised using a series of plots, as follows.

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/graphs/q1.png}
\end{center}
\caption{Time taken in milliseconds per subject to answer Question 1.}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/graphs/q2.png}
\end{center}
\caption{Time taken in milliseconds per subject to answer Question 2.}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/graphs/q3.png}
\end{center}
\caption{Time taken in milliseconds per subject to answer Question 3.}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/graphs/q4.png}
\end{center}
\caption{Time taken in milliseconds per subject to answer Question 4.}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/graphs/q5.png}
\end{center}
\caption{Time taken in milliseconds per subject to answer Question 5.}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/graphs/q6.png}
\end{center}
\caption{Time taken in milliseconds per subject to answer Question 6.}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/graphs/q7.png}
\end{center}
\caption{Time taken in milliseconds per subject to answer Question 7.}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/graphs/q8.png}
\end{center}
\caption{Time taken in milliseconds per subject to answer Question 8.}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/graphs/q9.png}
\end{center}
\caption{Time taken in milliseconds per subject to answer Question 9.}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/graphs/q10.png}
\end{center}
\caption{Time taken in milliseconds per subject to answer Question 10.}
\end{figure}
\end{center}

A two-sample, paired \emph{t}-test using an \emph{α} value of 0.05 was used to
determine whether or not the difference between the mean time taken to answer
each question by hand and using \emph{Nico} was statistically-significant.  The
paired \emph{t}-test was chosen as the samples are not independent.  The
results of the \emph{t}-tests on each question's datasets are shown in
\emph{Table x.y}.  The data is assumed to fit a normal distribution.  A
Shapiro-Wilk test was considered to test each dataset for normality, but the
sample size of eight data points per set (i.e. eight subjects for each
question) was deemed to be too small for such a test to have meaningful results.

% remove df (degrees of freedom)?
\begin{center}
\begin{table}[H]
\begin{center}
\begin{tabular}{|r|r|r|r|r|}
\hline
Question & \emph{t} & \emph{df} & \emph{p} & Significant?\\ \hline \hline
Q1 & -8.0204 & 7 & 0.00008968 & Yes\\ \hline
Q2 & -8.0493 & 7 & 0.00008764 & Yes\\ \hline
Q3 & -8.9296 & 7 & 0.00004489 & Yes\\ \hline
Q4 & -2.9592 & 7 & 0.02113 & Yes\\ \hline
Q5 & -5.288 & 7 &  0.001138 & Yes\\ \hline
Q6 & -1.3149 & 7 & 0.2300 & No\\ \hline
Q7 & 2.3688 & 7 &  0.0497 & Yes\\ \hline
Q8 & 3.1 & 7 & 0.01732 & Yes\\ \hline
Q9 & 4.0293 & 7 & 0.005 & Yes\\ \hline
Q10 & 2.1298 & 7 & 0.0707 & No\\
\hline
\end{tabular}
\end{center}
\caption{Table showing the results of the paired \emph{t}-test comparing the distribution of times taken to answer each question by hand and using the software, using an \emph{α} value of 0.05.}
\end{table}
\end{center}

As the \emph{p}-values in the above table indicate, there was a significant
difference in performance between using \emph{Nico} and completing the
questions by hand.  For the first five questions, the time taken to complete
the questions is markedly increased by using the software.  This is somewhat to
be expected;  the first five questions were `warm-up' questions, requiring a
maximum of three separate calculations to solve and with all numbers involved
in each calculation being less than ten.  Such questions were included to give
the user a chance to get used to solving simple problems using \emph{Nico},
before moving on to more complex tasks.  By the sixth question, there is no
longer a statistically-significant difference between using the software and
completing the questions by hand.  This particular question still uses numbers
less than ten, but requires several more nested calculations to solve,
suggesting that \emph{Nico} offers some improvement where the handwritten
method is lacking, but also that this is offset by the greater time required to
input very simple expressions into the application.  The final four questions
introduced numbers greater than ten, include many subcalculations and large
numbers.  For the seventh, eighth and ninth questions, \emph{Nico} offers a
statistically-significant improvement.  These questions involve the
manipulation of larger numbers, requiring strategies that go beyond simply
recalling number bonds, such as partitioning or long multiplication.  It is
these types of questions that \emph{Nico} is intended to make easier for the
user, and the often-dramatic decrease in the time taken to solve such questions
is shown to great effect here.  The tenth question, on reflection, was not
well-chosen.  It is comparable in difficulty to the fifth question, being a
series of simple subcalculations with numbers less than ten.  Though there are
more calculations to perform, and one operation involving a large number at the
end,  this question is not especially challenging to solve by hand, and as such
the lack of a significant difference between using the software and not doing
so is not entirely unexpected.  The simple subcalculations are easier to
perform by hand, and combining them is faster using \emph{Nico}.

Data were also collected regarding how well the questions were answered by each
user, which follow.

\begin{center}
\begin{table}[H]
\begin{center}
\begin{tabular}{|r||r|r||r|r||r|r||r|r|}
\cline{2-9}
\multicolumn{1}{c|}{} & \multicolumn{8}{c|}{Group 1}\\ \cline{2-9}
\multicolumn{1}{c|}{} & \multicolumn{2}{c||}{Subject 1} & \multicolumn{2}{c||}{Subject 2} & \multicolumn{2}{c||}{Subject 3} & \multicolumn{2}{c|}{Subject 4}\\ \hline
\multicolumn{1}{|c||}{Question} & \multicolumn{1}{c|}{Marks} & \multicolumn{1}{c||}{Errors} & \multicolumn{1}{c|}{Marks} & \multicolumn{1}{c||}{Errors} & \multicolumn{1}{c|}{Marks} & \multicolumn{1}{c||}{Errors} & \multicolumn{1}{c|}{Marks} & \multicolumn{1}{c|}{Errors}\\ \hline \hline
Q1 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0\\ \hline
Q2 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0\\ \hline
Q3 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0\\ \hline
Q4 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0\\ \hline
Q5 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0\\ \hline
Q6 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\ \hline
Q7 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0\\ \hline
Q8 & 0 & 0 & 1 & 1 & 1 & 0 & 1 & 0\\ \hline
Q9 & 0 & 0 & 1 & 0 & 1 & 1 & 1 & 1\\ \hline
Q10 & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 0\\ \hline
\multicolumn{9}{c}{}\\ \cline{2-9}
\multicolumn{1}{c|}{} & \multicolumn{8}{c|}{Group 2}\\ \cline{2-9}
\multicolumn{1}{c|}{} & \multicolumn{2}{c||}{Subject 1} & \multicolumn{2}{c||}{Subject 2} & \multicolumn{2}{c||}{Subject 3} & \multicolumn{2}{c|}{Subject 4}\\ \hline
\multicolumn{1}{|c||}{Question} & \multicolumn{1}{c|}{Marks} & \multicolumn{1}{c||}{Errors} & \multicolumn{1}{c|}{Marks} & \multicolumn{1}{c||}{Errors} & \multicolumn{1}{c|}{Marks} & \multicolumn{1}{c||}{Errors} & \multicolumn{1}{c|}{Marks} & \multicolumn{1}{c|}{Errors}\\ \hline \hline
Q1 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0\\ \hline
Q2 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0\\ \hline
Q3 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0\\ \hline
Q4 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 2\\ \hline
Q5 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 0\\ \hline
Q6 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0\\ \hline
Q7 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0\\ \hline
Q8 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1\\ \hline
Q9 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0\\ \hline
Q10 & 0 & 0 & 1 & 0 & 0 & 5 & 1 & 0\\
\hline
\end{tabular}
\end{center}
\caption{Table comparing the mark obtained for each question answered by hand (a correct answer scored 1, whereas an incorrect answer scored 0) to the number of attempts made to answer each question before submitting the correct answer in \emph{Nico}.}
\end{table}
\end{center}

% pearson product-moment correlation coefficient (pearson's r)?
% R: cor.test(x,y,alternative="g",method="p") to test if x, y have pos. corr. ("l" for neg.)
% should maybe concat all marks columns and all wrongs columns, then test marks against wrongs for marks wrongs
% or perhaps concat as above, then separate into the 1-markers and 0-markers
% then again, might be better to just take a mean of the wrongs with that data
% could even do this by question, e.g. if they got q1 wrong on paper they're more likely to get it wrong in the software, but getting q2 wrong might not mean shit
lol

\subsubsection{Feedback}
% feedback innit

\section{Goals}
% did it succeed?

\section{Summary}


\cleardoublepage
\chapter{Conclusions}
% did it achieve what was set out in the proposal?  300ms, etc.?
% does it work?
% user study
% what could be improved?
% overall, is it actually useful?

% lol




\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography

\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{refs}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{Questionnaire}

The questionnaire used in the user study follows.

\includepdf[pages=-]{qs.pdf}

\cleardoublepage

\chapter{Project Proposal}

The original project proposal follows.

\includepdf[pages=-]{proposal_rev04.pdf}
% \input{propbody}

\end{document}
