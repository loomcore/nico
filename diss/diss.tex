% The master copy of this demo dissertation is held on my filespace
% on the cl file serve (/homes/mr/teaching/demodissert/)

% Last updated by PMY on 3 March 2012

\documentclass[12pt,twoside,notitlepage,xetex]{report}

\usepackage{a4}
\usepackage{verbatim}
\usepackage{epsf}
\usepackage{sectsty}

\usepackage{url}
\usepackage{parskip}
\usepackage{pdfpages}
% \usepackage{wrapfig}
\usepackage{subfig}
\usepackage[normalem]{ulem}
\usepackage{caption}
\usepackage{color}
\usepackage{float}
% \usepackage{lettrine} % dropped capitals at start of chapter
\usepackage{fancyvrb}
% \usepackage{cprotect}

\usepackage{graphicx}
\usepackage{fontspec,xunicode}
\defaultfontfeatures{Mapping=tex-text, Numbers=Monospaced}% ,Scale=MatchLowercase}% , Numbers=OldStyle}
\setmainfont[Scale=1]{Linux Libertine O}% {Sabon MT Std}
\setsansfont{Roboto Bold}% {Myriad Pro Light}
\setmonofont[Scale=0.82]{Monaco}% {Droid Sans Mono}
\allsectionsfont{\sffamily}

\newfontinstance\bigsf[Color=000000,Scale=1.25]{Roboto Bold}% {Myriad Pro Light}
\newfontinstance\sfapp[Color=000000,Scale=0.82]{Roboto Regular}% {Myriad Pro Light}

\definecolor{red}{rgb}{0.80,0.00,0.00}
\definecolor{green}{rgb}{0.00,0.80,0.00}
\definecolor{blue}{rgb}{0.00,0.00,0.80}

\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex

\raggedbottom                           % try to avoid widows and orphans
\raggedright                            % left-aligned, not justified
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\renewcommand{\captionfont}{\footnotesize}

\setcounter{secnumdepth}{5}
% \setcounter{tocdepth}{5}

\begin{document}
\nocite{*}
\bibliographystyle{plain}% {unsrt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

% \hfill{\LARGE \bf \sffamily Philip Yeeles}
\hfill{\Large Philip Yeeles}

\vspace*{60mm}
\begin{center}
\LARGE
{\bf \bigsf Nico: An Environment for Mathematical Expression in Schools}\\
\vspace*{5mm}
% {\sffamily Computer Science Tripos} \\
Computer Science Tripos\\
\vspace*{5mm}
% {\sffamily Selwyn College} \\
Selwyn College\\
\vspace*{5mm}
% {\sffamily \today}  % today's date
\today % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
\bf Name:               & Philip Yeeles                                                   \\
\bf College:            & Selwyn College                                                  \\
\bf Project Title:      & Nico: An Environment for Mathematical\\
                        & Expression in Schools \\
\bf Examination:        & Computer Science Tripos, May 2012                               \\
\bf Word Count:         & TBC\footnotemark[1]
(well less than the 12000 limit) \\
\bf Project Originator: & P.~M.~Yeeles (\verb¬pmy22¬)                                    \\
\bf Supervisors:        & Dr S.~J.~Aaron (\verb¬sja55¬), A.~G.~Stead (\verb¬ags46¬)     \\
\end{tabular}
}
\footnotetext[1]{This word count was computed
by {\tt detex diss.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w}
}
\stepcounter{footnote}


\section*{Original Aims of the Project}

The aim of the project was to develop an application in the Clojure programming
language which would allow users to express mathematical calculations using a
graphical notation.  The software was to be able to generate an abstract syntax
tree from the graphical notation, evaluate it and pass the results back to the
application in under 300ms.  An extension to the project was to conduct a user
study to evaluate the utility of the software.
%
% To write a demonstration dissertation\footnote{A normal footnote without the
% complication of being in a table.} using \LaTeX\ to save
% student's time when writing their own dissertations. The dissertation
% should illustrate how to use the more common \LaTeX\ constructs. It
% should include pictures and diagrams to show how these can be
% incorporated into the dissertation.  It should contain the entire
% \LaTeX\ source of the dissertation and the Makefile.  It should
% explain how to construct an MSDOS disk of the dissertation in
% Postscript format that can be used by the book shop for printing, and,
% finally, it should have the prescribed layout and format of a diploma
% dissertation.


\section*{Work Completed}

I have successfully designed and implemented the application detailed in the
previous section.  That is, I have developed an application in which it is
possible to express calculations using a graphical notation, that generates an
abstract syntax tree from the language and that is able to parse the tree and
return the results in under 300ms.  I have also conducted a user study to assess
whether or not the software is actually of use with regard to mathematics
education.
%
% All that has been completed appears in this dissertation.

\section*{Special Difficulties}

Learning the Clojure programming language.
%
% Learning how to incorporate encapulated postscript into a \LaTeX\
% document on both CUS and Thor.

\newpage
\section*{Declaration of Originality}

I, Philip Michael Yeeles of Selwyn College, being a candidate for Part
II of the Computer Science Tripos, hereby declare that this dissertation
and the work described in it are my own work, unaided except as may be
specified below, and that the dissertation does not contain material
that has already been used to any substantial extent for a comparable
purpose.

\bigskip
\leftline{Signed}

\medskip
\leftline{Date \today}

\cleardoublepage

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}
My thanks to Luke Church for his advice regarding user studies, and to Alistair
Stead and Sam Aaron for their encouragement and patience.
%
% This document owes much to an earlier version written by Simon Moore
% \cite{Moore95}.  His help, encouragement and advice was greatly
% appreciated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering
                        % is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}
% TODO: sort out cogdims: apparently the proper way to do it is to mention cogdims and cite petra & green, then put all the cogdims terms in italics

% \lettrine{T}{he}
The aim of this project has been to design and develop a notation and
accompanying application to act as a learning aid for pre-algebra arithmetic by
increasing visibility, reducing the number of hidden dependencies and making the
flow of data obvious to the user.  I have successfully developed such a system,
intended initially for pupils in Year 5 (though extensible, through the creation
of alternative question sets, to other age groups), and, as an extension,
conducted a user study to assess its utility.

In this chapter, I will discuss my motivations for choosing this project, the
pros and cons of the handwritten system it is attempting to augment, the
technical challenges involved in developing such a system and related work that
has previously been conducted with similar goals.

\section{Motivations}
% evaluation of problems with writing it down on paper
% cogdims of handwritten method(s)
% system requirements (cogdims)

My motivations behind this project lay in the limitations of the handwritten
approach to solving mathematical problems that I had observed both in my own
learning and in my own teaching experience.  What follows is an evaluation of
the pros and cons of the handwritten method of performing arithmetic
calculations according to Blackwell and Green's ``Cognitive Dimensions''
framework \cite{Blackwell1998}, and a discussion of the properties a useful
alternative notation should have.

\pagebreak

% \subsection{Evaluation of the Handwritten Approach}
% % moved to chapter 2 requirements analysis

% \subsection{Requirements of a Replacement System}
% % moved to chapter 2 requirements analysis

\section{Technical Challenges}
% need first-class functions
% need to be able to pass expressions around to evaluate at will: hence functional, hence lisp - homoiconicity
% also need good gui libraries for app - familiar with java/swing so that works (esp. with seesaw), also the option of jfx2 and swt/guiftw
% difficulty of learning clojure over summer in preparation

Developing such an application comprises two main challenges: developing a
backend that is capable of creating, storing, editing, deleting, evaluating,
nesting and calculations, and a graphical, user-facing frontend that is able to
render calculations into the devised notation, and allow the user to perform
operations upon the notation that affect the underlying calculation.

I chose to use the Clojure language as it provided many features that would
prove to be useful over the course of the application's development.  As a
dialect of LISP, Clojure is a homoiconic programming language -- that is, a
programming language in which code is represented as a data structure -- which
made passing around and performing operations upon calculations themselves,
rather than just their results, considerably easier.  A calculation can simply
be represented as a piece of code, which can then be utilised as needed.

As the user experience is so crucial to the success of the application, it was
also important that there be well-established GUI libraries available.  Clojure
runs on the Java Virtual Machine (JVM), which puts Java's considerable standard
library at one's disposal, whilst still being able to program in a LISP.  As I
am familiar with Java and the Swing GUI libraries, it was advantageous to be
able to leverage this knowledge in designing the application's interface.

\section{Previous Work}
% scrubbing calculator http://worrydream.com/ScrubbingCalculator/
% soulver http://www.acqualia.com/soulver/
% neither really targeted at education
% cool stuff at http://worrydream.com/KillMath/ though
% maybe refer to this? http://betterexplained.com/articles/rethinking-arithmetic-a-visual-guide/
% also, this: http://www.ralph-abraham.org/articles/Blurbs/blurb126.shtml
% also, check out espresso and education city stuff, log in to fronter via st. mary's site, uname jyeele1.314, pword b3ach7
% plenty of work been done in making computer maths like paper maths, but not so much the reverse, case in point: http://www.macresearch.org/showcase-review-pi-cubed-iphone-ipod-touch
% also a lot of crap maths games that are essentially a series of qs in disguise, see http://www.time4learning.com/curriculum/try_demos.html
% nico is unabashedly *not* a game, rather a tool, much like a pen or calculator
% problem with calculators?

There already exists a wide variety of educational software for mathematics, but
much of this is in the form of ``games'', in which a series of mathematical
problems to be solved is poorly disguised as a game -- indeed, such problems
would be more accurately said to be embedded into a game, rather than becoming
the game themselves.  Thus, the object becomes not to solve the problems, but to
play the game that happens to surround the problems.  Such software also does
not often offer any means of solving the problems, other than the traditional
pen-and-paper method (with a piece of paper next to the computer screen), or
the mental approach.  Hence, what the user is then presented with is essentially
a game and a worksheet, awkwardly interleaved.  In some cases, it is even
possible for the user to simply press arbitrary buttons until they pass the
questions, effectively removing the maths element of the game and replacing it
with a series of short breaks in gameplay. % citations!

There also exist a few applications intended to represent calculations on a
computer in novel ways.  A relatively common approach to this has been to try
to make on-screen calculations more like on-paper calculations.  \emph{Pi Cubed}
takes this approach by trying to make complex calculations appear as they would
be written in an exam or exercise book \cite{PiCubed}.  \emph{Soulver},
conversely, tries to achieve this by simulating ``back-of-the-envelope''
calculations, whereby notes in English augment the calculation \cite{Soulver}.
Another approach is that of the \emph{Scrubbing Calculator} \cite{ScrubCalc},
which extends the \emph{Soulver}-style environment by helping the user to solve
equations by dragging values to increase and decrease them, showing how changing
a value affects the overall result.  Values can be linked by dragging a line
between them, which means that they are two instances of the same value -- hence
dragging one changes the value at every location in which it appears.  This is a
neat means of visualising equations, but it, too, is not intended for use in
education, and still requires the user to be able to formulate some kind of
equation.  The \emph{Scrubbing Calculator} is more a tool for facilitating
algebraic understanding, as opposed to arithmetic understanding; indeed, it is
inherently a {\bf calculator}, and so does not encourage thinking about how to
work out the arithmetic parts of a calculation manually.

\section{Summary}
% need a system that incorporates these features: foo, bar, baz, quux

Existing educational ``games'' for mathematics either have too much focus on
being a game, rather than helping to learn mathematics, or are such that the
mathematical element is circumventable.  There exists software to aid in
calculation and arithmetic by representing it clearly, but it is not intended
for educational use, and often its purpose is to make on-screen calculations
appear as one would handwrite them.

There is a niche for a tool for use in education that represents calculations in
a visual manner, with a particular focus on making the method by which arithmetic
problems are solved clear.  My project aims to provide an environment in which
the user can explore the many ways in which a problem can be solved using a
novel graphical notation.

\cleardoublepage



\chapter{Preparation}

% In this chapter I will discuss the work that was done prior to beginning the
% project proper.  This includes learning the Clojure programming language and
% researching and auditioning graphical metaphors for calculation.  This chapter
% comprises a requirements analysis, followed by an overview of the system
% architecture and a discussion of the additional tools used in the development of
% the project.
This chapter concerns the work that was completed prior to beginning the
project proper.  It comprises a requirements analysis, followed by a discussion
of the prototyping process of the graphical notation to be implemented in the
final application.  Finally, there will be a brief examination of the tools
used in the development of the project.

\section{Requirements Analysis}
% http://www.cs.fsu.edu/~lacher/courses/COP3331/rad.html
% http://www.nd.gov/itd/files/services/pm/requirements-analysis-guidebook.pdf

% TODO: write about the requirements analysis and why we're doing one

\subsection{Current System}
% move evaluation of handwritten arithmetic from chapter 1 here?

\begin{figure}
% \begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\subfloat[]{
\parbox{2cm}{
\begin{center}
{\small
24+35=59\\
12+48=60\\
59+72=131\\
1+60=61\\
131+61=192}
\end{center}}}
\subfloat[]{
\parbox{2cm}{
\begin{center}
{\small
24+35={\color{green}59}\\
12+48={\color{blue}60}\\
{\color{green}59}+72={\color{green}131}\\
1+{\color{blue}60}={\color{blue}61}\\
{\color{green}131}+{\color{blue}61}=192}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
{\small
24+35= {\color{red}\sout{59}} {\color{green}49}\\
12+48={\color{blue}60}\\
{\color{red}\sout{59}} {\color{green}49}+72= {\color{red}\sout{131}} {\color{green}121}\\
1+{\color{blue}60}={\color{blue}61}\\
{\color{red}\sout{131}} {\color{green}121}+{\color{blue}61}= {\color{red}\sout{192}} 182}
\end{center}}}
\end{center}
\caption{Illustrating the hidden dependencies and viscosity inherent in pre-algebra, handwritten arithmetic.  The original calculation is shown in (a), has its otherwise-hidden dependencies highlighted in (b), and is altered slightly in (c).}
% \end{wrapfigure}
\end{figure}
% cogdims
% taught method without being taught *why* it works
% high viscosity - have to cross things out or start again
% high repetition viscosity
% low knock-on viscosity
% viscosity is acceptable in transcription and incrementation, but harmful to modification and exploration
% hidden dependencies -
% premature commitment - made worse by high repetition viscosity; have to start again if a mistake is made
% premature commitment is certainly very high for traditional calculators
% algebra is abstraction-hungry, arthimetic is abstraction-hating, though can use secondary notation to construct abstractions
% no abstraction barrier to arithmetic though
% secondary notation - notes around calculations
% visibility - visible, but only juxtaposable if juxtaposed at the start (premature commitment) or with the help of secondary notation
There are a number of problems with handwritten, pre-algebra arithmetic that
this project seeks to rectify.  First of all, the fact that it is handwritten
entails a high level of viscosity: it is difficult to make changes to a written
calculation without sacrificing clarity.  In particular, there is a lot of
repetition viscosity involved in the modification of an existing piece of work;
if a number is changed that is used in several calculations, then it is
time-consuming to change it everywhere it appears in the working.  If several
calculations are dependent upon each other, then this entails a lot of knock-on
viscosity in recalculating each stage after changing the number.  This is
exacerbated by the hidden dependencies between chained calculations in
handwritten arithmetic (\emph{Fig. 2.1}).  The problem of hidden dependencies
is made worse by the low juxtaposability of the system; although the notation
is quite visible, in that every calculation can be seen easily on the page,
juxtaposing two sets of calculations entails considerable premature commitment
on the part of the user, as components cannot easily be edited or relocated due
to the system's high viscosity.  Whilst viscosity can be acceptable in some
situations, it is harmful with regard to modification and exploration within a
notational system, once again requiring a non-trivial amount of premature
commitment on the part of the user.  In many cases, it can actually quicker for
the user to start all over again, as opposed to making the changes required to
rectify their calculations.

Handwritten arithmetic does have one key advantage: it has a very low initial
abstraction barrier.  Other than learning the appropriate symbols for each
operation and digit, and how to combine them, the traditional system of
arithmetic allows a learner to begin using it almost immediately.  Algebra, on
the other hand, has a much higher abstraction barrier, requiring the much more
abstract concept of a variable, rather than a set quantity, to be used
effectively.  Although it is possible to add abstractions to arithmetic by the
use of secondary notation, there is no provision for abstraction included in
the primary notation.  It can, therefore, be said that algebra is an
\emph{abstraction-hungry} system, whereas arithmetic is an
\emph{abstraction-hating} system.  Without abstractions, arithmetic is easy to
get started with, but can be a very verbose and inefficient notation with low
visibility, as outlined above.

\subsection{Proposed System}

\subsubsection{Overview}
% cogdims!!
% need to develop useful notation - early studies, talk about other notations we came up with, notations looked at with alistair (get link)
% hidden dependencies - nico shows a data flow representation (p19, blackwell1998) to make dependencies explicit

% TODO: this bit.  not even sure if it should be in the intro...

To improve upon the standard approach of listing the steps comprising a
calculation, a system must acknowledge and try to overcome the drawbacks listed
above.  To this end, I have designed and developed a notational system and
accompanying applciation that aims to overcome many of the disadvantages
inherent in traditional, handwritten arithmetic.  The intention of the system
is to reduce viscosity, increase visibility and to remove many of the hidden
dependencies that beleaguer the traditional method. % TODO: not ahppy with this; not sure it counts as an overview


\subsubsection{Functional Requirements}

To be an improvement upon the current system detailed above, the new system must
satisfy the following properties:-- % TODO: not happy with this
\begin{itemize}
\item Allows the user to create graphical structures representative of complex calculations
\item Provides the user with a suitable environment in which to do so
\item Allows the user to reposition elements of the structure at will
\item Displays the user's current progress
\item Is able to evaluate the correctness of the user's answer
\item Accepts a file containing a set of questions to be answered
\item Displays the current question being answered
\item Progresses through the current question set as the user answers each question correctly
\end{itemize}

\subsubsection{Non-Functional Requirements}

The system must also satisfy a number of requirements outside of its basic
functionality.  These are listed below.
\begin{itemize}
\item Offers a significant improvement in visibility over handwritten arithmetic
\item Offers a significant improvement in juxtaposability over handwritten arithmetic
\item Reduces premature commitment relative to handwritten arithmetic
\item Reduces hidden dependencies relative to handwritten arithmetic
\item Is interactive: is able to pass results back to the user in less than 300ms\footnote{Roca and Rousseau \cite{Roca2004} have this to say on the subject of interactivity: ``An abundance of studies into user tolerance of round-trip latency [...] has been conducted and generally agrees upon the following levels of tolerance: excellent, 0-300ms; good, 300-600ms; poor, 600-700ms; and quality becomes unacceptable [...] in excess of 700ms.''}
\item Is appealing to the target audience of 9- to 10-year-olds without being childish -- must be applicable to a wider audience if needed (e.g. could it be extended for use in adult education?)
\end{itemize}
% talk about needing to be appealing, etc.?
% more details in notes on user interface subsection in chapter 3

% \subsubsection{Use Case}
%
% % diagram?  see wikipedia "use case"
% lol

% \section{System Overview}
% % do we need if in req. analysis?
%
% lol

\section{User Interface}
% section rather than subsection?  def. section if we don't have system overview
% prototypes!  dig out the preliminary drawings, take screenshots of old versions for later

As this project is primarily concerned with human-computer interaction, the
user interface and experience, and the design thereof, constitutes a
significant part of this project.  As such, this section outlines the initial
development stages of the user interface, first introducing several designs for
the graphical notation, and then discussing in more detail three that were
developed further.

\subsection{Prototyping}

\subsubsection{Low-Fidelity Prototyping}

% drawings 'n' shit
% talk about how decided to come up with 20 different designs then thin them out
To try to get some initial ideas for what could become the calculation metaphor
of choice for the project, a target was set of devising at least twenty,
significantly different, potential designs.  These were recorded as very rough
sketches, a few of which were refined in larger examples, and three of which
were deemed good enough to warrant an application mockup, as detailed in
\emph{Sec. 2.2.1.2}.

% \newpage

% \paragraph{Flowgraphs}\hfill

\begin{center}
\begin{figure}[H]
% \begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11a.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11b.jpg}
\end{center}}}
\end{center}
\caption{Early designs for flowgraph-based calculation metaphors.}
% \end{wrapfigure}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{figs/mockups/sketches/11/11jii.jpg}
\end{center}
\caption{A more refined sketch of a flowgraph-based language and application.}
\end{figure}
\end{center}

% \newpage

% \paragraph{Triangles}\hfill

\begin{center}
\begin{figure}[H]
% \begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/21/21b.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/22/22a.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/22/22b.jpg}
\end{center}}}\\
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/42/42a.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/42/42b.jpg}
\end{center}}}
\end{center}
\caption{Early designs for triangle-based calculation metaphors.}
% \end{wrapfigure}
\end{figure}
\end{center}

\begin{center}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{figs/mockups/sketches/31/31a.jpg}
\end{center}
\caption{A more refined sketch of a triangle-based language.}
\end{figure}
\end{center}

% \newpage

% \paragraph{Circles}\hfill

\begin{center}
\begin{figure}[H]
% \begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12a.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12b.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12c.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12f.jpg}
\end{center}}}\\
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12h.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/41/41a.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/41/41b.jpg}
\end{center}}}
\end{center}
\caption{Early designs for circle-based calculation metaphors.}
% \end{wrapfigure}
\end{figure}
\end{center}

\begin{center}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{figs/mockups/sketches/21/21a.jpg}
\end{center}
\caption{A more refined sketch of a circle-based language.}
\end{figure}
\end{center}

% \newpage

% \paragraph{Other}\hfill

\begin{center}
\begin{figure}[H]
% \begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11c.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11d.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11e.jpg}
\end{center}}}\\
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11f.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11g.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11h.jpg}
\end{center}}}
\end{center}
\end{figure}
\newpage
\begin{figure}
\ContinuedFloat
\begin{center}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11i.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11k.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11li.jpg}
\end{center}}}\\
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11lii.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/11/11m.jpg}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12d.jpg}
\end{center}}}\\
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12e.jpg}
\end{center}}}
\end{center}
\caption{Assorted early designs for other calculation metaphors.}
% \end{wrapfigure}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[H]
\begin{center}
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12gi.jpg}
\end{center}}}
{\Huge $ \rightarrow $}% arrow
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12gii.jpg}
\end{center}}}
{\Huge $ \rightarrow $}\\% arrow
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12giii.jpg}
\end{center}}}
{\Huge $ \rightarrow $}% arrow
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12giv.jpg}
\end{center}}}
{\Huge $ \rightarrow $}% arrow
\subfloat[]{
\parbox{4cm}{
\begin{center}
\includegraphics[width=4cm]{figs/mockups/sketches/12/12gv.jpg}
\end{center}}}
\end{center}
\caption{A sample progression of a calculation in a language based around infinitely halving a rectangle.}
\end{figure}
\end{center}

% \newpage

% \subsubsection{Preliminary Designs}
\subsubsection{Detailed Mockups}
% examples done using that prototyping software - balsamiq mockups
% draft designs on pwf

Some preliminary designs for the application and graphical language follow,
being more mature versions of three of the low-fidelity prototypes presented
above.  First is a combined flowgraph representation and
Read-Evaluate-Print-Loop (REPL) design.  The second design uses the Sierpiński
triangle as a basis for the visual metaphor.  The final design is the
circle-based language that eventually became the foundation for the rest of the
project.

\paragraph{Flowgraph Metaphor}\hfill

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-4cm]{figs/mockups/flowgraph/img/fg-000.jpg}
\caption{The prototype flowgraph-style language.}
\end{center}
\end{figure}

The flowgraph idea initially outlined in the project proposal and included in
the low-fidelity prototypes above appears here as a more mature, revised
prototype, showing two screens of a sample application.  The top screen shows
the proposed application manipulating the graphical language, whilst the bottom
screen shows a REPL utilising a simple text-based language for users more
comfortable with writing than the visual metaphor.

% TODO: add scroll bar to box selection panel?  have claimed that it's scrollable but it's not showing it!
% TODO: similarly for the canvas
The application is comprised of one window containing several panels.  The
current question being answered is displayed in the top left-hand corner.
Below this, a scrollable panel running down the left side of the window
contains the fundamental components of the notation: boxes representing numbers
and operations, both provided and user-defined, with two buttons below to
change the action of clicking the mouse (explained in greater detail below).  A
panel that runs along the top of the window contains output boxes, areas that
display the result of a calculation at a user-determined point in the
application.  Further boxes appear here as the user demands them, by using the
{\sfapp Show} function.  The {\sfapp ANS} box is a specialised case of this,
which displays what the user currently wishes to submit as the answer to the
question.  The canvas panel occupies the majority of the window, and this is
the area in which the answer is constructed using the various components of the
graphical language.  In the top right-hand corner of the canvas are three
buttons, to zoom in and out of the current calculation and to bring up a help
window.  For especially large or zoomed-in calculations, the canvas is
scrollable.  At the bottom of the window are two tabs, {\sfapp Flow} and
{\sfapp Worksheet}.  When {\sfapp Flow} is selected, the graphical language is
available for use in answering the question.  When {\sfapp Worksheet} is
selected, the user is able to use a simple textual language in a REPL to answer
the question.

Of all the prototypes shown here, this version of the graphical language is the
most like a traditional programming language, in that it allows the user to
define reusable functions, and includes functionality similar to print
statements.  The icons at the side of the application are used to select the
desired function, from a set that includes addition, subtraction,
multiplication, division, exponentiation, number input, {\sfapp Show},
{\sfapp Define} and {\sfapp Join}.  Addition, subtraction, multiplication,
division and exponentiation are all dragged-and-dropped from the icons at the
side to a point on the canvas, causing a box containing their respective
functions to appear at that point.  Number input ({\sfapp \#}) is similar, but
the user inputs a number using the keyboard after the box is created.  The box
then contains that number.  {\sfapp Show} displays the output of the junction to
which its arrow points, in the output box at the top of the screen with the label
input by the user after placing it.  If the box with the label does not yet
exist, it is created next to the existing output boxes.  {\sfapp Define} and
{\sfapp Join} are not boxes to be dragged-and-dropped; they are modes of
operation.  When {\sfapp Define} is activated, dragging the mouse on the canvas
draws a box around sections of the diagram -- the user is able to define
functions by doing so, and by providing a label for the section of diagram that
has been highlighted, a corresponding box can be dragged-and-dropped from the
list of icons (as show in \emph{Fig. 2.2} with the {\sfapp times ten}
function).  When {\sfapp Join} is active, dragging between two points on the
canvas creates an arrow between them that means that the source of the arrow is
used as an argument to the destination of the arrow.  In defining functions,
if arrows cross the boundary of the definition box and they are incoming, input
is required to future uses of the function.  One outgong arrow is allowed to
indicate the output of the function.  Using this notation, answers are submitted
by {\sfapp Show}ing the output at a point in the calculation to the output box
{\sfapp ANS}.

This particular graphical language tries to have a very high visibility,
minimising the number of hidden dependencies between calculations by making
every connection explicit: as a dataflow representation of a calculation
\cite{Blackwell1998}, the flow of information through the diagram is made very
clear.  This language is considerably less viscous than the handwritten method,
as it is trivial (albeit not demonstrated in \emph{Fig. 2.2}) to remove and
replace a box or arrow in the diagram, as opposed to writing out a new set of
calculations or replacing several instances of a component by crossing them
out.  Each box is able to be relocated on the canvas, increasing the
juxtaposability of the system, and the user is able to define their own
abstractions.

The textual language improves upon the traditional means of handwriting
arithmetic by revealing otherwise-hidden dependencies using references to line
numbers.  As the target audience is not yet required to have formally learnt
(or, indeed, encountered) algebra, this notation includes a function \verb¬:¬,
which takes a single number \emph{n} as an argument and returns the result of the
calculation performed on line \emph{n}.  Answers are submitted using a function
\verb¬answer¬ that takes a single number (shown here using a line reference that
is resolved to a number) as an argument.  Other functions include addition,
subtraction, multiplication, division and exponentiation, all of which take two
or more numerical arguments and are used in the familiar infix form.  A function
\verb¬define¬ is also included, although not shown here.  Finally, there is the
\verb¬show¬ function, which behaves similarly to a print statement.  It takes a
numerical argument \emph{n} followed by a string argument \verb¬str¬, and
displays \emph{n} in the output box named \verb¬str¬ at the top of the screen.
If there exists no such output box, it is created next to the existing boxes.
Note that \verb¬answer n¬ is logically equivalent to \verb¬show n "ANS"¬; the
\verb¬answer¬ function was included here to increase clarity.

This design was abandoned as it was deemed to be too complex for the target
audience (Year 5).  The intention of this project is not to implement yet
another programming language for learners, and by providing features like the
REPL and function definition, the system unnecessarily overprovides.  In
addition to this, the flowgraph representation had a number of shortcomings.
For example, it is not immediately clear in what order the arguments feed into
an operation, which is confusing for non-commutative functions such as
subtraction.  Furthermore, the language is quite verbose.  Although this is not
inherently a disadvantage, a more compact representation would be preferable,
in order to make expressions written in the notations more readable to people
other than the author.

\paragraph{Sierpiński Triangle Metaphor}\hfill

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{figs/mockups/sierp/sierp_mockup_full.png}
\caption{The prototype Sierpiński-triangle-based language.}
\end{center}
\end{figure}

This prototype uses a zooming instance of the Sierpiński triangle fractal as
the basis of its notation.  It is shown here manipulating a simple calculation.

The application consists of a single window containing two panels and a canvas
area.  The right-hand panel displays the current total of the calculation,
and the other panel displays the question currently being answered.  In the
canvas area, there are buttons for zooming in and out, a help button and
buttons controlling the composition of structures within the language.  When a
triangle has been selected by clicking on it, clicking the {\sfapp Op} button
presents the user with a choice of operations (namely +, -, × and ÷) to use in
the bottom segment of the triangle.  Clicking either of the {\sfapp Input}
buttons allows the user to input a value into their respective sections, and
clicking on the {\sfapp Split} button creates a new triangle expression within
the left-hand triangle.

This notational system is based around binary operations represented as the
component triangles of a Sierpiński fractal, the logic behind this being that
the fractal structure emphasises that each calculation is part of a larger
whole.  The notation is read by using the left and right sub-triangles as
arguments (left first, right second) to the operation in the bottom triangle.
The structure is colour-coded, such that each subexpression is a different
colour to its precedent superexpression.  This allows the user to abstract away
subexpressions as units to be manipulated as any other input to an operation
would be.  The hidden dependencies of the handwritten method are greatly
diminished in this manner, as viewing the internal structure of a
calculation's subexpressions is simply a matter of zooming-in to the
appropriate triangle.  Viscosity is also considerably reduced, as making a
change in one expression does not require the change to made anywhere else, as
the results of that expression are passed to the rest of the calculation.  This
does not completely remove viscosity, as a misresrepresented value still has to
be replaced several times if it appears in several different expressions, but
this is still an improvement over handwriting.  Indeed, the fact that
calculations are editable more than once, by virtue of using a computer rather
than paper, makes this less viscous than pen and paper.  The system is quite
visible, but has a very low juxtaposability, as all calculations are restricted
to their respective places in the triangle template.

This design was ultimately abandoned as it was deemed to be awkward for a
number of reasons, not least because it was based solely around binary
operations, meaning that to solve the simple question 1+2+3+4, one has to either
calculate ((1+2)+3)+4, which is inefficient, or mentally calculate that
1+2+3=6, and then calculate 6+4, which is obviously unacceptable for a system
that intends to help the user express themselves mathematically.  The severe
lack of juxtaposability is also a problem: as each expression must fit into the
larger structure, it is not possible to reorder them at will, without
fundamentally altering the calculation being performed.  It also enforces a
top-down approach to calculation: one is required by the system to begin with the
outermost calculation and work inwards.  There is no provision for putting a
larger triangle around an existing calculation.  In addition to this, a
somewhat-informal survey of potential notations was conducted, asking
approximately ten subjects to answer some sample questions in this notation and
the circle-based notation (below).  Subjects found this notation less clear,
and were much better able to complete questions correctly using the circle
notation.
% survey
% TODO: can't put subexpressions into right-hand triangle

% what/mockup
% application
% language
% abandoned

\paragraph{Circle Metaphor}\hfill

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{figs/mockups/circles/nico_circmock.png}
\caption{The prototype circle-based language.}
\end{center}
\end{figure}

This prototype uses a notation based around circles as individual units of
calculation, linked in such a way as to indicate the flow of information.
Although it is related to the flowgraph metaphor (above), it has a number of
key differences.

The application comprises, similarly to the Sierpiński model above, a single
window with two panels and a scrollable canvas area, with some buttons to
control the input of data.  The right-hand panel shows a running total of the
user's calculation, and the other panel shows the question currently being
answered.  The canvas area has three buttons at the bottom: zoom in, zoom out
and help.  The larger buttons above these control the action that clicking the
mouse on the canvas performs.  When {\sfapp New} is active, clicking on the
canvas creates a new circle at that location.  When {\sfapp Split} is active,
clicking on a circle increases the number of arguments it has (initially two,
up to a maximum of eight).  When {\sfapp Function} is selected, clicking on a
circle presents the user with a choice of +, -, × and ÷ to use as that circle's
operation.  When {\sfapp Input} is selected, as shown in \emph{Fig. 2.4}, the
user is presented with two further options, {\sfapp Number} and
{\sfapp Circle}.  When {\sfapp Number} is active, clicking on a circle's
argument allows the user to change the value of that argument.  When
{\sfapp Circle} is active, the user is able to click and drag from one circle
to an argument of another, indicating that they wish to use the results of one
circle's calculation as the argument to another circle's calculation.  Finally,
the {\sfapp Answer} button submits the current total as the answer to the
current question.

This notational system uses linked circles representing individual expressions
as its primary metaphor for constructing calculations.  It is similar to the
flowgraph metaphor presented above, except that instead of boxes for each
argument and operation all linked together, single, linkable objects in this
system are complete expressions, rather than components.  Also, there is only
one visible output, namely the overall result of the calculation as a whole.
As for the circles themselves, they consist of an operation at the centre,
orbited by arguments, which are evaluated clockwise from 0°.  Each argument can
either be a number or the tail of another circle, representing the result of
the calculation that that circle stands for.  The circles are colour-coded,
with each `layer' having its own colour.  In this case, the root circle is red,
the circles feeding directly into it are yellow, the circles feeding into those
circles are green and the circles feeding into those are blue.  It is possible
to move circles around the canvas by clicking and dragging them to the desired
location.  Compared to the handwritten approach, this notational system is much
more visible, and very much more juxtaposable, allowing the user to construct
the diagram in a way that is comfortable for them, and allowing them to compare
elements side-by-side if they need to.  Unlike with the Sierpiński metaphor,
the user is not restricted to one order or pattern of constructing a
calculation: calculations can be performed bottom-up, top-down or a mixture of
both, as is comfortable for the individual user.  The system of tails feeding
into other circles also makes the dataflow clear, eliminating many of the
hidden dependencies of handwritten calculation.  For similar reasons to the
flowgraph metaphor, the circle notation also reduces viscosity, as changing a
subexpression automatically alters all of its superexpressions.  Finally, the
system requires little premature commitment, as piece of the diagram can be
created, deleted and swapped in and out at will, so it is ideal for
exploration, allowing the user to try many ways of solving a problem within the
application, rather than having to use a secondary notation or device to help
work through a problem in a more familiar manner and then transcripting that
solution into the new notation.

This design was the one that was ultimately chosen as the basis for the project
as it neatly solved, or at least ameliorated, many of the problems listed with
handwritten arithmetic, without being too complex for the target audience (as
with the flowgraph system), and without being too restrictive with regard to
mathematical expression.  In addition to this, the results of the survey
mentioned above also indicated that people got on well with this notation; the
test subjects found it considerably easier to use than the Sierpiński notation,
and made fewer mistakes in handwriting this notation than the alternative.
% survey

% what/mockup
% application
% language
% chosen

% \section{Additional Tools}

% Luke's:
% Throughout the project, I developed additional support tools to assist with
% design, development and testing. These will be described at the relevant place
% in the implementation chapter.
% lol

% \subsection{Third-Party Tools}
\section{Third-Party Tools}

What follows is a list of the third-party tools that were used in the
development of the project.
\begin{itemize}
\item Ubuntu Linux 10.04, Arch Linux 2010.05, Microsoft Windows 7
\item Clojure 1.2.0
\item Leiningen 1.6.1.1
\item OpenJDK 6
\item Seesaw 1.3.1-SNAPSHOT
\item swank-clojure 1.3.4-SNAPSHOT
\item GNU Emacs 23.1.1
\item A modified version of Overtone's Emacs configuration \cite{OvertoneEmacsD}, including:--
\begin{itemize}
\item SLIME/SWANK (revision as of 15/10/2009)
\item clojure-mode 1.11.5
\item undo-tree 0.3.3
\end{itemize}
\item Git 1.7.0.4
\item GitHub
\item Balsamiq Mockups
\item Google Docs
\item R 2.15.0
\end{itemize}

\section{Summary}

In this chapter, the work done in preparation for beginning the main
implementation of the project was detailed.  A thorough requirements analysis
has been conducted to outline the expected behaviour of the product,
contrasting it with the existing system of handwritten calculations.  In
\emph{Sec. 2.2}, prototype designs for a suitable graphical notation were
introduced.  Three in particular were explored in detail, before deciding on
the final notation upon which to base the project.  The next chapter contains a
detailed analysis of the work completed to implement the project.

\cleardoublepage
\chapter{Implementation}

This chapter details the implementation of the project.  The code itself totals
approximately 1,500 lines of Clojure, and the resultant application,
\emph{Nico}, satisfies the requirements laid out in the project proposal,
namely:--
\begin{center}
\parbox[c]{\textwidth-2cm}{
\small
``[to be] able to generate an abstract syntax tree in Clojure from the graphical language and evaluate such a tree, passing the results back to the graphical application and displaying this to user in less than 300ms.''
}
\end{center}
In addition to this, an extension to the project was completed, in the form of
a study that tested the software on real people.

\section{System Architecture}
% TODO: intro?

% \subsection{Overview}
% overview of the system architecture
% diagram kinda replaces this section; will keep the diagram and just launch straight into the detailed subsections

\emph{{\sc Note:} Bit stuck with this chapter; I feel like I'm just writing down arbitrary bits of things that happened during the project without any overall feel for how this fits together as a chapter.}

% TODO: sort out all the pictures, pdfxetex just can't handle that shit (i.e. scaling images - do it in gimp or something)
\begin{center}
\begin{figure}[H]
\begin{center}
\subfloat[Clojure backend]{
\parbox{4cm}{
\begin{center}
\includegraphics[height=4cm]{figs/clj.png}
\end{center}}}
{\Huge $ \leftrightarrow $}% arrow
\subfloat[Swing/Seesaw interaction handler]{
\parbox{4cm}{
\begin{center}
\includegraphics[height=4cm]{figs/duke.png}
\end{center}}}
{\Huge $ \leftrightarrow $}% arrow
\subfloat[User interface]{
\parbox{5cm}{
\begin{center}
\includegraphics[height=4cm]{figs/nico_screen_01.png}
\end{center}}}
\caption{An overview of the system architecture.  \emph{Nico} is divided into three logically-separate units: the user-facing application, the interaction handler and the backend.}
\end{center}
\end{figure}
\end{center}

\emph{{\sc Note:} Not sure about the ordering of these subsections; this may change.}

\subsection{Backend}
% calculations as data structures (lists to be evaled)
% rendering engine
% questions and marking
% question syntax
% questions as data structures (lists to be evaled)
% the fact that they are essentially answers means that answers can easily be compared to them, as well as manipulated and stuff - case in point, all the question-highlighting bullshit
% interactivity (300ms rule, see proposal for citation)
% very little mutable state
% placeholders?  why were they introduced?  how did they make things easier?  what problems did they solve?

The application backend handles the mathematical aspect of the application;
that is, it is able to interpret data gathered from the user's input and
process it as a calculation.  Each circle is represented by an associative map,
of the form \verb¬{:x 123 :y 234 :name "c0" :circ (+ 1 2 3 4)}¬, where the
\verb¬:x¬ and \verb¬:y¬ fields are numbers representative of the circle's
co-ordinates on the canvas, the \verb¬:name¬ field is a string used to refer to
the circle and the \verb¬:circ¬ field is an S-expression representative of the
calculation that the circle contains.  This S-expression can use any of five
operators: \verb¬+¬, \verb¬-¬, \verb¬*¬, \verb¬/¬ and finally \verb¬\?¬, a
placeholder for initialising circles.  Similarly, the arguments to the operator
can be either numbers or the placeholder character \verb¬\?¬.  A Clojure agent,
\verb¬used-circles¬,  stores a list of all the circles currently in use.

\emph{Nico's} backend stores and manages circles and questions using five
Clojure agents: \verb¬used-circles¬, containing a list of associative maps as
detailed above, \verb¬current-qset¬, also containing a list of associative
maps, this time representative of the questions to be answered (using a format
of \verb¬{:n 1 :q (* 2 (+ 1 2 3) 7) :a? false :c? false}¬, where \verb¬:n¬ is
the question number, \verb¬:q¬ is an S-expression representing the current
question, and \verb¬:a?¬ and \verb¬:c?¬ are artefacts left over from a previous
revision of the software, and are no longer used), \verb¬circle-number¬,
containing an integer counting how many circles have previously been created
whilst answering this question, \verb¬current-coords¬, which tracks the current
co-ordinates of the mouse cursor, and \verb¬current-question¬, containing an
integer indicating the number of the question currently being answered.

\begin{center}
\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-2cm]{figs/nico_backend.pdf}
\end{center}
\caption{A rough model of \emph{Nico's} management of mutable state.}
\end{figure}
\end{center}

\verb¬used-circles¬ is an agent containing a list of associative maps, as
detailed above.  \emph{Nico} includes two main functions for the management of
circles, namely \verb¬new-circle¬ and \verb¬del-circle¬.  \verb¬new-circle¬
creates an associative map initialised to the following values:
% TODO: also maybe talk about kill-used-circles

\begin{center}
\begin{figure}[H]
\begin{center}
\begin{minipage}{2.5in}% {\textwidth-2cm}
\begin{Verbatim}[fontsize=\small,numbers=left]
{:x (- (:x @current-coords) 50)
 :y (- (:y @current-coords) 50)
 :name (str "c" @circle-number)
 :circ (\? \? \?)}
\end{Verbatim}
\end{minipage}
\end{center}
\caption{The function {\ttfamily new-circle} initialises a circle centred on the current location of the mouse cursor, generating a name {\ttfamily "c}\emph{n}{\ttfamily "}, where \emph{n} is the number of circles that have previously been created and with an initial expression of {\ttfamily (\textbackslash? \textbackslash? \textbackslash?)}.}
\end{figure}
\end{center}

This map is then sent off to \verb¬used-circles¬.  The value of \verb¬circle-number¬ is incremented by one, and the user-facing canvas area is cleared and re-rendered.

\verb¬del-circle¬ is a more complex function that removes a circle from
\verb¬used-circles¬, taking either a string or two integers as its arguments.
If a string is passed to it, the function iterates across the contents of
\verb¬used-circles¬, reconstructing the list by \verb¬cons¬ing each element in
turn on to a new list.  If the \verb¬:name¬ field of the head of the
\verb¬used-circles¬ list matches the argument passed to \verb¬del-circle¬, the
function recurses without \verb¬cons¬ing that element on to the new list, thus
constructing a new version of the \verb¬used-circles¬ list with the desired
circle removed, which can then be sent off to the \verb¬used-circles¬ agent.
In the case that two integers (i.e. a pair of co-ordinates) is passed to
\verb¬del-circle¬, the function uses two extra local variables, \verb¬c¬ and
\verb¬c?¬, to determine which circle is being deleted.  To determine the value
of \verb¬c¬, the function calls \verb¬point-in-circle¬ on the provided
co-ordinates, which is another function that, if the co-ordinates are within
the boundaries of a circle, returns the \verb¬:name¬ field of that circle (or
\verb¬nil¬ otherwise).  \verb¬c?¬ tests whether or not \verb¬c¬ is equal to
\verb¬nil¬.  If \verb¬c?¬ has the value \verb¬false¬, then the co-ordinates
passed to \verb¬del-circle¬ are not in any circle, and hence nothing can be
deleted.  In this case, the function returns \verb¬nil¬.  In the case that
\verb¬c?¬ has the value \verb¬true¬, the function proceeds as if id had been
provided with a string rather than two integers, using the value of \verb¬c¬ as
the string to compare to.  Also included is a related function,
\verb¬kill-used-circles¬, that initialises \verb¬used-circles¬ to the empty
list.

To determine the current value of the user's calculation, two functions are
used: \verb¬find-root¬ and \verb¬eval-circle¬.

\verb¬find-root¬ finds the circle that is not used as an argument to any other
circle.  If there are two circles that match this criterion, \verb¬find-root¬
returns the first instance that it encounters; that is, the first instance of
a `root' circle.  As a complete calculation must only have one root circle
(else it would be two separate calculations), this is not problematic for
answer-checking.  However, it can be mildly confusing for the user if they are
constructing a calculation by constructing two subexpressions and merging them
at the end, and a future improvement to this design could be to find the root
of the calculation that the mouse is hovering over.  Regardless,
\verb¬find-root¬ works by iterating across \verb¬used-circles¬ and returning
the first circle that causes another function, \verb¬root?¬, to return the
value \verb¬true¬.  \verb¬root?¬ iterates across \verb¬used-circles¬, comparing
its single argument, a circle, to each of the other available circles in turn
using another function, \verb¬is-arg?¬, which takes the \verb¬:name¬ field of
its first argument and returns \verb¬true¬ if that name appears as a symbol
anywhere in the \verb¬:circ¬ field of its second argument.

\verb¬eval-circle¬ takes a circle as its argument and returns an S-expression
representative of the calculation that that circle represents, recursively
evaluating any circles that are contained within the argument circle.  It works
by iterating across the \verb¬:circ¬ field of its argument, \verb¬cons¬ing each
element on to a new list.  If an element is of type \verb¬clojure.lang.Symbol¬,
\verb¬eval-circle¬ calls \verb¬eval-circle¬ on the circle that the symbol
points to, which is resolved using a function \verb¬find-circle¬ that iterates
across \verb¬used-circles¬, trying to match each circle's \verb¬:name¬ field
against its argument.  \verb¬eval-circle¬ is then able to return a nested
S-expression that represents a calculation.  When used in conjunction with
\verb¬find-root¬, this function is able to resolve the entire diagram that has
been constructed on the canvas into a single S-expression, which can then be
evaluated or otherwise utilised as needed.

\begin{center}
\begin{figure}[H]
\begin{center}
\begin{minipage}{\textwidth-2cm}
\begin{Verbatim}[fontsize=\small,numbers=left]
(defn eval-circle
  "Iterates across a circle list, resolving
   symbols into their respective circles."
  [circ]
  (loop [c (:circ (remove-placeholders circ))
         out '()]
    (cond (empty? c) (reverse out)
          (= (first c) \?) 0
          (symbol? (first c)) (cond
                                (nested?
                                  (find-circle
                                    (str
                                      (first c))))
                                  (recur (rest c)
                                         (cons (eval-circle
                                                 (find-circle
                                                   (str
                                                     (first c))))
                                               out))
                                :else (recur (rest c)
                                             (cons (:circ
                                                     (find-circle
                                                       (str
                                                         (first c))))
                                                   out)))
          :else (recur (rest c)
                       (cons (first c)
                             out)))))
\end{Verbatim}
\end{minipage}
\end{center}
\caption{The {\ttfamily eval-circle} source.}
\end{figure}
\end{center}

% TODO: talk about interesting problems with del-circle-safe

\subsection{Interaction Handler}
% the bit that handles all the application shit: render, main-window, etc.
% talk about jfx2 vs. guiftw/swt vs. seesaw/swing

\emph{{\sc Note:} These paragraphs aren't in the correct order yet; I've just been writing things that I want to include in this subsection, and will reorder them when I have a better idea of where this bit's going.}

% TODO: more!  this shouldn't be the first (or last) paragraph in this section
My original intention was to develop \emph{Nico} using the JavaFX library.
However, a number of difficulties were encountered with this: firstly, JavaFX
version 2.0 was not available for Linux, my primary development environment, at
the time of beginning the project.  Although I had access to Windows machines,
this was not an ideal situation.  Regardless, I tried to begin development on a
Windows machine, using JavaFX, but faced a number of problems with
installation.  Deciding that it would be better to get on with the project
rather than spending any more time installing a library, I decided to proceed
using the Eclipse Foundation's SWT toolkit and Szymon Witamborski's (santamon)
corresponding Clojure bindings, GUI FTW!, to interface with it.  After spending
some time developing the backend, I began work on the user interface.  I
encountered many problems with SWT and GUI FTW!, particularly regarding drawing
arbitrary shapes on the canvas area and regarding extracting user input from
dialogue boxes.  Admittedly, this was most likely due to my unfamiliarity with
SWT, but in the interests of keeping the project on-schedule, I decided to
migrate what I had already constructed of the interface over to Java Swing,
using David Ray's (daveray) Seesaw library to provide convenient bindings for
Clojure.  Ray's excellent bindings, coupled with my own previous experience
with Swing from earlier in the tripos, served to greatly assist development,
overcome what had become one of the larger stumbling blocks in this project.

% TODO: also not in the right order
At the heart of the interaction handler is a function called \verb¬render¬.
This is the function that is called every time what is displayed on the canvas
needs to be updated.  It calls \verb¬clear-screen¬, which paints a white
rectangle over the canvas, followed by the bin icon, and then iterates across
\verb¬used-circles¬, calling a function \verb¬draw-circle¬ on each circle in
turn.  \verb¬draw-circle¬ determines what operation its argument circle uses,
and selects a colour scheme accordingly.  It then contains a sequence of paint
instructions that construct the circle on the canvas.  Finally, it calls
\verb¬draw-args¬, followed by \verb¬link-circles¬.  \verb¬draw-args¬ removes
the first element of its argument's \verb¬:circ¬ field and draws each of the
remaining elements at hardcoded co-ordinates relative to the \verb¬:x¬ and
\verb¬:y¬ values of the circle, with different sets of co-ordinates according
to how many arguments the circle has.  \verb¬link-circles¬ uses data from the
same sets of co-ordinates to determine which argument the user is trying to
replace with input from another circle, and draws a line from underneath the
source circle to the desired point on the destination circle, followed by a
small circle around that point to make it clear that this circle is receiving
the results of the other circle.

\emph{{\sc Note:} This is as far as I've got (about halfway by my reckoning).  }\verb¬texcount¬\emph{ tells me I've got about 5,800 words.}

\subsection{User Interface}
% target audience - children (year 5), but also applications in remedial adult learning (i.e. can't be too childish)
% hence must be appealing, clear, easy-to-read, not too verbose
% prototypes! take screenshots of old versions
% talk about main-window here i guess?

\section{Application}
% application in which the language is manipulated
% talk about how the app has changed, show screenshots
% talk about how the app becamse more minimalist, to focus on the language itself
% language as a main focus, with useful information n shit around it in the app
% colour-coding text (though consider colour-blindness with the red and green text)
% question highlighting - talk about troubles with it, but also merits of including it

\subsection{Notation}%metaphor?
% graphical language itself
% show previous versions
% talk about how the circles have to make clear e.g. arg order
% talk about how circles had to be improved, show iterations

\section{Summary}




\cleardoublepage
\chapter{Evaluation}

% lol

\section{Backend Testing}
% used slime/swank with test lines as comments to be evaluated with C-x C-e
% emacs/slime/swank as ide; ideal for lisps!
% lein test framework - need to actually set up some tests first though!

\section{UI Evaluation}
% user testing
% graphs

\section{Language Evaluation}
% user testing
% graphs

\section{User Study}
% results

\section{Goals}
% did it succeed?

\section{Summary}


\cleardoublepage
\chapter{Conclusions}
% did it achieve what was set out in the proposal?  300ms, etc.?
% does it work?
% what could be improved?
% overall, is it actually useful?

% lol




\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography

\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{refs}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{Project Proposal}

The original project proposal follows.

\includepdf[pages=-]{proposal_rev04.pdf}
% \input{propbody}

\end{document}
