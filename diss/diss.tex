% The master copy of this demo dissertation is held on my filespace
% on the cl file serve (/homes/mr/teaching/demodissert/)

% Last updated by PMY on 3 March 2012

\documentclass[12pt,twoside,notitlepage,xetex]{report}

\usepackage{a4}
\usepackage{verbatim}
\usepackage{epsf}
\usepackage{sectsty}

\usepackage{url}
\usepackage{parskip}
\usepackage{pdfpages}
% \usepackage{wrapfig}
\usepackage{subfig}
\usepackage[normalem]{ulem}
\usepackage{caption}
\usepackage{color}
\usepackage{float}

\usepackage{graphicx}
\usepackage{fontspec,xunicode}
\defaultfontfeatures{Mapping=tex-text, Numbers=Monospaced}% ,Scale=MatchLowercase}% , Numbers=OldStyle}
\setmainfont[Scale=1]{Linux Libertine O}% {Sabon MT Std}
\setsansfont{Roboto Bold}% {Myriad Pro Light}
\setmonofont[Scale=0.82]{Monaco}% {Droid Sans Mono}
\allsectionsfont{\sffamily}

\newfontinstance\bigsf[Color=000000,Scale=1.25]{Roboto Bold}% {Myriad Pro Light}
\newfontinstance\sfapp[Color=000000,Scale=0.82]{Roboto Regular}% {Myriad Pro Light}

\definecolor{red}{rgb}{0.80,0.00,0.00}
\definecolor{green}{rgb}{0.00,0.80,0.00}
\definecolor{blue}{rgb}{0.00,0.00,0.80}

\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex

\raggedbottom                           % try to avoid widows and orphans
\raggedright                            % left-aligned, not justified
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\renewcommand{\captionfont}{\footnotesize}

\setcounter{secnumdepth}{5}
% \setcounter{tocdepth}{5}

\begin{document}
\nocite{*}
\bibliographystyle{plain}% {unsrt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

% \hfill{\LARGE \bf \sffamily Philip Yeeles}
\hfill{\Large Philip Yeeles}

\vspace*{60mm}
\begin{center}
\LARGE
{\bf \bigsf Nico: An Environment for Mathematical Expression in Schools}\\
\vspace*{5mm}
% {\sffamily Computer Science Tripos} \\
Computer Science Tripos\\
\vspace*{5mm}
% {\sffamily Selwyn College} \\
Selwyn College\\
\vspace*{5mm}
% {\sffamily \today}  % today's date
\today % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
\bf Name:               & Philip Yeeles                                                   \\
\bf College:            & Selwyn College                                                  \\
\bf Project Title:      & Nico: An Environment for Mathematical\\
                        & Expression in Schools \\
\bf Examination:        & Computer Science Tripos, May 2012                               \\
\bf Word Count:         & TBC\footnotemark[1]
(well less than the 12000 limit) \\
\bf Project Originator: & P.~M.~Yeeles (\verb¬pmy22¬)                                    \\
\bf Supervisors:        & Dr S.~J.~Aaron (\verb¬sja55¬), A.~G.~Stead (\verb¬ags46¬)     \\
\end{tabular}
}
\footnotetext[1]{This word count was computed
by {\tt detex diss.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w}
}
\stepcounter{footnote}


\section*{Original Aims of the Project}

The aim of the project was to develop an application in the Clojure programming
language which would allow users to express mathematical calculations using a
graphical notation.  The software was to be able to generate an abstract syntax
tree from the graphical notation, evaluate it and pass the results back to the
application in under 300ms.  An extension to the project was to conduct a user
study to evaluate the utility of the software.
%
% To write a demonstration dissertation\footnote{A normal footnote without the
% complication of being in a table.} using \LaTeX\ to save
% student's time when writing their own dissertations. The dissertation
% should illustrate how to use the more common \LaTeX\ constructs. It
% should include pictures and diagrams to show how these can be
% incorporated into the dissertation.  It should contain the entire
% \LaTeX\ source of the dissertation and the Makefile.  It should
% explain how to construct an MSDOS disk of the dissertation in
% Postscript format that can be used by the book shop for printing, and,
% finally, it should have the prescribed layout and format of a diploma
% dissertation.


\section*{Work Completed}

I have successfully designed and implemented the application detailed in the
previous section.  That is, I have developed an application in which it is
possible to express calculations using a graphical notation, that generates an
abstract syntax tree from the language and that is able to parse the tree and
return the results in under 300ms.  I have also conducted a user study to assess
whether or not the software is actually of use with regard to mathematics
education.
%
% All that has been completed appears in this dissertation.

\section*{Special Difficulties}

Learning the Clojure programming language.
%
% Learning how to incorporate encapulated postscript into a \LaTeX\
% document on both CUS and Thor.

\newpage
\section*{Declaration of Originality}

I, Philip Michael Yeeles of Selwyn College, being a candidate for Part
II of the Computer Science Tripos, hereby declare that this dissertation
and the work described in it are my own work, unaided except as may be
specified below, and that the dissertation does not contain material
that has already been used to any substantial extent for a comparable
purpose.

\bigskip
\leftline{Signed}

\medskip
\leftline{Date \today}

\cleardoublepage

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}
My thanks to Luke Church for his advice regarding user studies, and to Alistair
Stead and Sam Aaron for their encouragement and patience.
%
% This document owes much to an earlier version written by Simon Moore
% \cite{Moore95}.  His help, encouragement and advice was greatly
% appreciated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering
                        % is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}

The aim of this project has been to design and develop a notation and
accompanying application to act as a learning aid for pre-algebra arithmetic by
increasing visibility, reducing the number of hidden dependencies and making the
flow of data obvious to the user.  I have successfully developed such a system,
intended initially for pupils in Year 5 (though extensible, through the creation
of alternative question sets, to other age groups), and, as an extension,
conducted a user study to assess its utility.

In this chapter, I will discuss my motivations for choosing this project, the
pros and cons of the handwritten system it is attempting to augment, the
technical challenges involved in developing such a system and related work that
has previously been conducted with similar goals.

\section{Motivations}
% evaluation of problems with writing it down on paper
% cogdims of handwritten method(s)
% system requirements (cogdims)

My motivations behind this project lay in the limitations of the handwritten
approach to solving mathematical problems that I had observed both in my own
learning and in my own teaching experience.  What follows is an evaluation of
the pros and cons of the handwritten method of performing arithmetic
calculations according to Blackwell and Green's ``Cognitive Dimensions''
framework \cite{Blackwell1998}, and a discussion of the properties a useful
alternative notation should have.

\pagebreak

\subsection{Evaluation of the Handwritten Approach}

\begin{figure}
% \begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\subfloat[]{
\parbox{2cm}{
\begin{center}
{\small
24+35=59\\
12+48=60\\
59+72=131\\
1+60=61\\
131+61=192}
\end{center}}}
\subfloat[]{
\parbox{2cm}{
\begin{center}
{\small
24+35={\color{green}59}\\
12+48={\color{blue}60}\\
{\color{green}59}+72={\color{green}131}\\
1+{\color{blue}60}={\color{blue}61}\\
{\color{green}131}+{\color{blue}61}=192}
\end{center}}}
\subfloat[]{
\parbox{4cm}{
\begin{center}
{\small
24+35= {\color{red}\sout{59}} {\color{green}49}\\
12+48={\color{blue}60}\\
{\color{red}\sout{59}} {\color{green}49}+72= {\color{red}\sout{131}} {\color{green}121}\\
1+{\color{blue}60}={\color{blue}61}\\
{\color{red}\sout{131}} {\color{green}121}+{\color{blue}61}= {\color{red}\sout{192}} 182}
\end{center}}}
\end{center}
\caption{Illustrating the hidden dependencies and viscosity inherent in pre-algebra, handwritten arithmetic.  The original calculation is shown in (a), has its otherwise-hidden dependencies highlighted in (b), and is altered slightly in (c).}
% \end{wrapfigure}
\end{figure}
% cogdims
% taught method without being taught *why* it works
% high viscosity - have to cross things out or start again
% high repetition viscosity
% low knock-on viscosity
% viscosity is acceptable in transcription and incrementation, but harmful to modification and exploration
% hidden dependencies -
% premature commitment - made worse by high repetition viscosity; have to start again if a mistake is made
% premature commitment is certainly very high for traditional calculators
% algebra is abstraction-hungry, arthimetic is abstraction-hating, though can use secondary notation to construct abstractions
% no abstraction barrier to arithmetic though
% secondary notation - notes around calculations
% visibility - visible, but only juxtaposable if juxtaposed at the start (premature commitment) or with the help of secondary notation
There are a number of problems with handwritten, pre-algebra arithmetic that
this project seeks to rectify.  First of all, the fact that it is handwritten
entails a high level of viscosity: it is difficult to make changes to a written
calculation without sacrificing clarity.  In particular, there is a lot of
repetition viscosity involved in the modification of an existing piece of work;
if a number is changed that is used in several calculations, then it is time-
consuming to change it everywhere it appears in the working.  If several
calculations are dependent upon each other, then this entails a lot of knock-on
viscosity in recalculating each stage after changing the number.  This is
exacerbated by the hidden dependencies between chained calculations in
handwritten arithmetic (\emph{Fig. 1.1}).  The problem of hidden dependencies
is made worse by the low juxtaposability of the system; although the notation
is quite visible, in that every calculation can be seen easily on the page,
juxtaposing two sets of calculations entails considerable premature commitment
on the part of the user, as components cannot easily be edited or relocated due
to the system's high viscosity.  Whilst viscosity can be acceptable in some
situations, it is harmful with regard to modification and exploration within a
notational system, once again requiring a non-trivial amount of premature
commitment on the part of the user.  In many cases, it can actually quicker for
the user to start all over again, as opposed to making the changes required to
rectify their calculations.

Handwritten arithmetic does have one key advantage: it has a very low initial
abstraction barrier.  Other than learning the appropriate symbols for each
operation and digit, and how to combine them, the traditional system of
arithmetic allows a learner to begin using it almost immediately.  Algebra, on
the other hand, has a much higher abstraction barrier, requiring the much more
abstract concept of a variable, rather than a set quantity, to be used
effectively.  Although it is possible to add abstractions to arithmetic by the
use of secondary notation, there is no provision for abstraction included in
the primary notation.  It can, therefore, be said that algebra is an
\emph{abstraction-hungry} system, whereas arithmetic is an
\emph{abstraction-hating} system.  Without abstractions, arithmetic is easy to
get started with, but can be a very verbose and inefficient notation with low
visibility, as outlined above.

\subsection{Requirements of a Replacement System}
% cogdims!!
% need to develop useful notation - early studies, talk about other notations we came up with, notations looked at with alistair (get link)
% hidden dependencies - nico shows a data flow representation (p19, blackwell1998) to make dependencies explicit

% TODO: this bit.  not even sure if it should be in the intro...

To improve upon the standard approach of listing the steps comprising a
calculation, a system must acknowledge and try to overcome the drawbacks listed
above.  To this end, I have designed and developed a notational system and
accompanying applciation that aims to overcome many of the disadvantages
inherent in traditional, handwritten arithmetic.  The intention of the system
is to reduce viscosity, increase visibility and to remove many of the hidden
dependencies that beleaguer the traditional method.

\section{Technical Challenges}
% need first-class functions
% need to be able to pass expressions around to evaluate at will: hence functional, hence lisp - homoiconicity
% also need good gui libraries for app - familiar with java/swing so that works (esp. with seesaw), also the option of jfx2 and swt/guiftw
% difficulty of learning clojure over summer in preparation

Developing such an application comprises two main challenges: developing a
backend that is capable of creating, storing, editing, deleting, evaluating,
nesting and calculations, and a graphical, user-facing frontend that is able to
render calculations into the devised notation, and allow the user to perform
operations upon the notation that affect the underlying calculation.

I chose to use the Clojure language as it provided many features that would
prove to be useful over the course of the application's development.  As a
dialect of LISP, Clojure is a homoiconic programming language -- that is, a
programming language in which code is represented as a data structure -- which
made passing around and performing operations upon calculations themselves,
rather than just their results, considerably easier.  A calculation can simply
be represented as a piece of code, which can then be utilised as needed.

As the user experience is so crucial to the success of the application, it was
also important that there be well-established GUI libraries available.  Clojure
runs on the Java Virtual Machine (JVM), which puts Java's considerable standard
library at one's disposal, whilst still being able to program in a LISP.  As I
am familiar with Java and the Swing GUI libraries, it was advantageous to be
able to leverage this knowledge in designing the application's interface.

\section{Previous Work}
% scrubbing calculator http://worrydream.com/ScrubbingCalculator/
% soulver http://www.acqualia.com/soulver/
% neither really targeted at education
% cool stuff at http://worrydream.com/KillMath/ though
% maybe refer to this? http://betterexplained.com/articles/rethinking-arithmetic-a-visual-guide/
% also, this: http://www.ralph-abraham.org/articles/Blurbs/blurb126.shtml
% also, check out espresso and education city stuff, log in to fronter via st. mary's site, uname jyeele1.314, pword b3ach7
% plenty of work been done in making computer maths like paper maths, but not so much the reverse, case in point: http://www.macresearch.org/showcase-review-pi-cubed-iphone-ipod-touch
% also a lot of crap maths games that are essentially a series of qs in disguise, see http://www.time4learning.com/curriculum/try_demos.html
% nico is unabashedly *not* a game, rather a tool, much like a pen or calculator
% problem with calculators?

There already exists a wide variety of educational software for mathematics, but
much of this is in the form of ``games'', in which a series of mathematical
problems to be solved is poorly disguised as a game -- indeed, such problems
would be more accurately said to be embedded into a game, rather than becoming
the game themselves.  Thus, the object becomes not to solve the problems, but to
play the game that happens to surround the problems.  Such software also does
not often offer any means of solving the problems, other than the traditional
pen-and-paper method (with a piece of paper next to the computer screen), or
the mental approach.  Hence, what the user is then presented with is essentially
a game and a worksheet, awkwardly interleaved.  In some cases, it is even
possible for the user to simply press arbitrary buttons until they pass the
questions, effectively removing the maths element of the game and replacing it
with a series of short breaks in gameplay. % citations!

There also exist a few applications intended to represent calculations on a
computer in novel ways.  A relatively common approach to this has been to try
to make on-screen calculations more like on-paper calculations.  \emph{Pi Cubed}
takes this approach by trying to make complex calculations appear as they would
be written in an exam or exercise book \cite{PiCubed}.  \emph{Soulver},
conversely, tries to achieve this by simulating ``back-of-the-envelope''
calculations, whereby notes in English augment the calculation \cite{Soulver}.
Another approach is that of the \emph{Scrubbing Calculator} \cite{ScrubCalc},
which extends the \emph{Soulver}-style environment by helping the user to solve
equations by dragging values to increase and decrease them, showing how changing
a value affects the overall result.  Values can be linked by dragging a line
between them, which means that they are two instances of the same value -- hence
dragging one changes the value at every location in which it appears.  This is a
neat means of visualising equations, but it, too, is not intended for use in
education, and still requires the user to be able to formulate some kind of
equation.  The \emph{Scrubbing Calculator} is more a tool for facilitating
algebraic understanding, as opposed to arithmetic understanding; indeed, it is
inherently a {\bf calculator}, and so does not encourage thinking about how to
work out the arithmetic parts of a calculation manually.

\section{Summary}
% need a system that incorporates these features: foo, bar, baz, quux

Existing educational ``games'' for mathematics either have too much focus on
being a game, rather than helping to learn mathematics, or are such that the
mathematical element is circumventable.  There exists software to aid in
calculation and arithmetic by representing it clearly, but it is not intended
for educational use, and often its purpose is to make on-screen calculations
appear as one would handwrite them.

There is a niche for a tool for use in education that represents calculations in
a visual manner, with a particular focus on making the method by which arithmetic
problems are solved clear.  My project aims to provide an environment in which
the user can explore the many ways in which a problem can be solved using a
novel graphical notation.

\cleardoublepage



\chapter{Preparation}

In this chapter I will discuss the work that was done prior to beginning the
project proper.  This includes learning the Clojure programming language and
researching and auditioning graphical metaphors for calculation.  This chapter
comprises a requirements analysis, followed by an overview of the system
architecture and a discussion of the additional tools used in the development of
the project.

\section{Requirements Analysis}
% http://www.cs.fsu.edu/~lacher/courses/COP3331/rad.html
% http://www.nd.gov/itd/files/services/pm/requirements-analysis-guidebook.pdf

\subsection{Current System}
% move evaluation of handwritten arithmetic from chapter 1 here?

\subsection{Proposed System}

\subsubsection{Overview}

\subsubsection{Functional Requirements}

To be an improvement upon the current system detailed above, the new system must
satisfy the following properties:--
\begin{itemize}
\item lol
\end{itemize}

\subsubsection{Non-Functional Requirements}

The system must also satisfy a number of requirements outside of its basic
functionality.  These are listed below.
\begin{itemize}
\item lol
\end{itemize}

\subsubsection{Use Case}
% diagram?  see wikipedia "use case"

% \section{System Overview}
% % do we need if in req. analysis?
%
% lol

\section{User Interface}
% section rather than subsection?  def. section if we don't have system overview
% prototypes!  dig out the preliminary drawings, take screenshots of old versions for later

lol

\subsection{Prototyping}

\subsubsection{Low-Fidelity Prototyping}
% drawings 'n' shit
% talk about how decided to come up with 20 different designs then thin them out

\begin{figure}[H]
% \begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\subfloat[]{
\parbox{6cm}{
\begin{center}
\includegraphics[width=6cm]{figs/lol.jpg}
\end{center}}}
\subfloat[]{
\parbox{6cm}{
\begin{center}
\includegraphics[width=6cm]{figs/lol.jpg}
\end{center}}}\\
\subfloat[]{
\parbox{6cm}{
\begin{center}
\includegraphics[width=6cm]{figs/lol.jpg}
\end{center}}}
\subfloat[]{
\parbox{6cm}{
\begin{center}
\includegraphics[width=6cm]{figs/lol.jpg}
\end{center}}}
\end{center}
\caption{Empress Alexandra II Sexah}
% \end{wrapfigure}
\end{figure}

\subsubsection{Preliminary Designs}
% examples done using that prototyping software - balsamiq mockups
% draft designs on pwf

Some preliminary designs for the application and graphical language follow.
First is a combined flowgraph representation and Read-Evaluate-Print-Loop (REPL)
design.  The second design uses the Sierpiński triangle as a basis for the
visual metaphor.  The final design is the circle-based language that eventually
became the foundation for the rest of the project.

\paragraph{Flowgraph Metaphor}\hfill

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth-4cm]{figs/mockups/flowgraph/img/fg-000.jpg}
\caption{The prototype flowgraph-style language.}
\end{center}
\end{figure}

The flowgraph idea initially outlined in the project proposal and included in
the low-fidelity prototypes above appears here as a more mature, revised
prototype, showing two screens of a sample application.  The top screen shows
the proposed application manipulating the graphical language, whilst the bottom
screen shows a REPL utilising a simple text-based language for users more
comfortable with writing than the visual metaphor.

% TODO: add scroll bar to box selection panel?  have claimed that it's scrollable but it's not showing it!
% TODO: similarly for the canvas
The application is comprised of one window containing several panels.  The
current question being answered is displayed in the top left-hand corner.
Below this, a scrollable panel running down the left side of the window
contains the fundamental components of the notation: boxes representing numbers
and operations, both provided and user-defined, with two buttons below to
change the action of clicking the mouse (explained in greater detail below).  A
panel that runs along the top of the window contains output boxes, areas that
display the result of a calculation at a user-determined point in the
application.  Further boxes appear here as the user demands them, by using the
{\sfapp Show} function.  The {\sfapp ANS} box is a specialised case of this,
which displays what the user currently wishes to submit as the answer to the
question.  The canvas panel occupies the majority of the window, and this is
the area in which the answer is constructed using the various components of the
graphical language.  In the top right-hand corner of the canvas are three
buttons, to zoom in and out of the current calculation and to bring up a help
window.  For especially large or zoomed-in calculations, the canvas is
scrollable.  At the bottom of the window are two tabs, {\sfapp Flow} and
{\sfapp Worksheet}.  When {\sfapp Flow} is selected, the graphical language is
available for use in answering the question.  When {\sfapp Worksheet} is
selected, the user is able to use a simple textual language in a REPL to answer
the question.

Of all the prototypes shown here, this version of the graphical language is the
most like a traditional programming language, in that it allows the user to
define reusable functions, and includes functionality similar to print
statements.  The icons at the side of the application are used to select the
desired function, from a set that includes addition, subtraction,
multiplication, division, exponentiation, number input, {\sfapp Show},
{\sfapp Define} and {\sfapp Join}.  Addition, subtraction, multiplication,
division and exponentiation are all dragged-and-dropped from the icons at the
side to a point on the canvas, causing a box containing their respective
functions to appear at that point.  Number input ({\sfapp \#}) is similar, but
the user inputs a number using the keyboard after the box is created.  The box
then contains that number.  {\sfapp Show} displays the output of the junction to
which its arrow points, in the output box at the top of the screen with the label
input by the user after placing it.  If the box with the label does not yet
exist, it is created next to the existing output boxes.  {\sfapp Define} and
{\sfapp Join} are not boxes to be dragged-and-dropped; they are modes of
operation.  When {\sfapp Define} is activated, dragging the mouse on the canvas
draws a box around sections of the diagram -- the user is able to define
functions by doing so, and by providing a label for the section of diagram that
has been highlighted, a corresponding box can be dragged-and-dropped from the
list of icons (as show in \emph{Fig. 2.2} with the {\sfapp times ten}
function).  When {\sfapp Join} is active, dragging between two points on the
canvas creates an arrow between them that means that the source of the arrow is
used as an argument to the destination of the arrow.  In defining functions,
if arrows cross the boundary of the definition box and they are incoming, input
is required to future uses of the function.  One outgong arrow is allowed to
indicate the output of the function.  Using this notation, answers are submitted
by {\sfapp Show}ing the output at a point in the calculation to the output box
{\sfapp ANS}.

This particular graphical language tries to have a very high visibility,
minimising the number of hidden dependencies between calculations by making
every connection explicit: as a dataflow representation of a calculation
\cite{Blackwell1998}, the flow of information through the diagram is made very
clear.  This language is considerably less viscous than the handwritten method,
as it is trivial (albeit not demonstrated in \emph{Fig. 2.2}) to remove and
replace a box or arrow in the diagram, as opposed to writing out a new set of
calculations or replacing several instances of a component by crossing them
out.  Each box is able to be relocated on the canvas, increasing the
juxtaposability of the system, and the user is able to define their own
abstractions.

The textual language improves upon the traditional means of handwriting
arithmetic by revealing otherwise-hidden dependencies using references to line
numbers.  As the target audience is not yet required to have formally learnt
(or, indeed, encountered) algebra, this notation includes a function \verb¬:¬,
which takes a single number \emph{n} as an argument and returns the result of the
calculation performed on line \emph{n}.  Answers are submitted using a function
\verb¬answer¬ that takes a single number (shown here using a line reference that
is resolved to a number) as an argument.  Other functions include addition,
subtraction, multiplication, division and exponentiation, all of which take two
or more numerical arguments and are used in the familiar infix form.  A function
\verb¬define¬ is also included, although not shown here.  Finally, there is the
\verb¬show¬ function, which behaves similarly to a print statement.  It takes a
numerical argument \emph{n} followed by a string argument \verb¬str¬, and
displays \emph{n} in the output box named \verb¬str¬ at the top of the screen.
If there exists no such output box, it is created next to the existing boxes.
Note that \verb¬answer n¬ is logically equivalent to \verb¬show n "ANS"¬; the
\verb¬answer¬ function was included here to increase clarity.

This design was abandoned as it was deemed to be too complex for the target
audience (Year 5).  The intention of this project is not to implement yet
another programming language for learners, and by providing features like the
REPL and function definition, the system unnecessarily overprovides.  In
addition to this, the flowgraph representation had a number of shortcomings.
For example, it is not immediately clear in what order the arguments feed into
an operation, which is confusing for non-commutative functions such as
subtraction.  Furthermore, the language is quite verbose.  Although this is not
inherently a disadvantage, a more compact representation would be preferable,
in order to make expressions written in the notations more readable to people
other than the author.

\paragraph{Sierpiński Triangle Metaphor}\hfill

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{figs/mockups/sierp/sierp_mockup_full.png}
\caption{The prototype Sierpiński-triangle-based language.}
\end{center}
\end{figure}

This prototype uses a zooming instance of the Sierpiński triangle fractal as
the basis of its notation.  It is shown here manipulating a simple calculation.

The application consists of a single window containing two panels and a canvas
area.  The right-hand panel displays the current total of the calculation,
and the other panel displays the question currently being answered.  In the
canvas area, there are buttons for zooming in and out, a help button and
buttons controlling the composition of structures within the language.  When a
triangle has been selected by clicking on it, clicking the {\sfapp Op} button
presents the user with a choice of operations (namely +, -, × and ÷) to use in
the bottom segment of the triangle.  Clicking either of the {\sfapp Input}
buttons allows the user to input a value into their respective sections, and
clicking on the {\sfapp Split} button creates a new triangle expression within
the left-hand triangle.

This notational system is based around binary operations represented as the
component triangles of a Sierpiński fractal, the logic behind this being that
the fractal structure emphasises that each calculation is part of a larger
whole.  The notation is read by using the left and right sub-triangles as
arguments (left first, right second) to the operation in the bottom triangle.
The structure is colour-coded, such that each subexpression is a different
colour to its precedent superexpression.  This allows the user to abstract away
subexpressions as units to be manipulated as any other input to an operation
would be.  The hidden dependencies of the handwritten method are greatly
diminished in this manner, as viewing the internal structure of a
calculation's subexpressions is simply a matter of zooming-in to the
appropriate triangle.  Viscosity is also considerably reduced, as making a
change in one expression does not require the change to made anywhere else, as
the results of that expression are passed to the rest of the calculation.  This
does not completely remove viscosity, as a misresrepresented value still has to
be replaced several times if it appears in several different expressions, but
this is still an improvement over handwriting.  Indeed, the fact that
calculations are editable more than once, by virtue of using a computer rather
than paper, makes this less viscous than pen and paper.  The system is quite
visible, but has a very low juxtaposability, as all calculations are restricted
to their respective places in the triangle template.

This design was ultimately abandoned as it was deemed to be awkward for a
number of reasons, not least because it was based solely around binary
operations, meaning that to solve the simple question 1+2+3+4, one has to either
calculate ((1+2)+3)+4, which is inefficient, or mentally calculate that
1+2+3=6, and then calculate 6+4, which is obviously unacceptable for a system
that intends to help the user express themselves mathematically.  The severe
lack of juxtaposability is also a problem: as each expression must fit into the
larger structure, it is not possible to reorder them at will, without
fundamentally altering the calculation being performed.  In addition to this, a
somewhat-informal survey of potential notations was conducted, asking
approximately ten subjects to answer some sample questions in this notation and
the circle-based notation (below).  Subjects found this notation less clear,
and were much better able to complete questions correctly using the circle
notation.
% survey

% what/mockup
% application
% language
% abandoned

\paragraph{Circle Metaphor}\hfill

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{figs/mockups/circles/nico_circmock.png}
\caption{The prototype circle-based language.}
\end{center}
\end{figure}

This prototype uses a notation based around circles as individual units of
calculation, linked in such a way as to indicate the flow of information.
Although it is related to the flowgraph metaphor (above), it has a number of
key differences.

The application

This notational system

This design was the one that was ultimately chosen as % survey

% what/mockup
% application
% language
% chosen

\section{Additional Tools}

% Luke's:
% Throughout the project, I developed additional support tools to assist with
% design, development and testing. These will be described at the relevant place
% in the implementation chapter.
lol

\subsection{Third-Party Tools}

What follows is a list of the third-party tools that were used in the
development of the project.
\begin{itemize}
\item Ubuntu Linux 10.04, Arch Linux 2010.05, Microsoft Windows 7
\item Clojure 1.2.0
\item Leiningen 1.6.1.1
\item OpenJDK 6
\item Seesaw 1.3.1-SNAPSHOT
\item swank-clojure 1.3.4-SNAPSHOT
\item GNU Emacs 23.1.1
\item A modified version of Overtone's Emacs configuration \cite{OvertoneEmacsD}, including:--
\begin{itemize}
\item SLIME/SWANK (revision as of 15/10/2009)
\item clojure-mode 1.11.5
\item undo-tree 0.3.3
\end{itemize}
\item Git 1.7.0.4
\item GitHub
\item Balsamiq Mockups
\item Google Docs
\end{itemize}

\section{Summary}


\cleardoublepage
\chapter{Implementation}

lol

\section{Backend}
% calculations as data structures (lists to be evaled)
% rendering engine
% questions and marking
% question syntax
% questions as data structures (lists to be evaled)
% the fact that they are essentially answers means that answers can easily be compared to them, as well as manipulated and stuff - case in point, all the question-highlighting bullshit
% interactivity (300ms rule, see proposal for citation)

\section{User Interface}
% target audience - children (year 5), but also applications in remedial adult learning (i.e. can't be too childish)
% hence must be appealing, clear, easy-to-read, not too verbose
% prototypes! take screenshots of old versions

\subsection{Metaphor}
% graphical language itself
% show previous versions
% talk about how the circles have to make clear e.g. arg order
% talk about how circles had to be improved, show iterations

\subsection{Application}
% application in which the language is manipulated
% talk about how the app has changed, show screenshots
% talk about how the app becamse more minimalist, to focus on the language itself
% language as a main focus, with useful information n shit around it in the app
% colour-coding text (though consider colour-blindness with the red and green text)
% question highlighting - talk about troubles with it, but also merits of including it

\section{Summary}




\cleardoublepage
\chapter{Evaluation}

lol

\section{Backend Testing}
% used slime/swank with test lines as comments to be evaluated with C-x C-e
% emacs/slime/swank as ide; ideal for lisps!
% lein test framework - need to actually set up some tests first though!

\section{UI Evaluation}
% user testing
% graphs

\section{Language Evaluation}
% user testing
% graphs

\section{Summary}


\cleardoublepage
\chapter{Conclusions}
% did it achieve what was set out in the proposal?  300ms, etc.?
% does it work?
% what could be improved?
% overall, is it actually useful?

lol




\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography

\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{refs}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{Project Proposal}

The original project proposal follows.

\includepdf[pages=-]{proposal_rev04.pdf}
% \input{propbody}

\end{document}
